<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Satellite Simulation - HTML Controls</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/arcazj/openbexi_earth_orbit/master/css/style.css">
    <style>
        /* Minimal inline styles, if any, specific to HTML structure before CSS loads */
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
        }

        canvas {
            display: block; /* Default for the main 3D canvas */
        }

        /* Menu Toggle Button */
        #menuToggleBtn {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1001; /* Above controls container */
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border: 1px solid #666;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            transition: left 0.3s ease-in-out;
        }

        /* Controls Container (Menu Panel) */
        #controlsContainer {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(40, 40, 40, 0.9);
            padding: 15px;
            border-radius: 8px;
            width: 280px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease-in-out;
            transform: translateX(0%); /* Initially visible */
        }

        #controlsContainer.menu-hidden {
            transform: translateX(calc(-100% - 20px)); /* Slide out completely */
        }

        /* Version Display within Menu */
        #versionDisplay {
            color: #888;
            font-size: 12px;
            text-align: center;
            padding: 5px 0 10px 0;
            border-bottom: 1px solid #555;
            margin-bottom: 10px;
            word-wrap: break-word; /* Ensure long links don't break layout */
        }

        #versionDisplay a {
            color: #00aaff; /* Link color */
            text-decoration: none;
        }

        #versionDisplay a:hover {
            text-decoration: underline;
        }

        /* Control Groups within Menu */
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #555;
        }

        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        /* Collapsible Section Headers (H3) */
        #controlsContainer h3 {
            color: #00aaff;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #controlsContainer h3 .toggle-icon {
            font-size: 12px;
            margin-left: 8px;
            transition: transform 0.2s ease-in-out;
        }

        #controlsContainer h3 .toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        /* Collapsible Content Styling */
        .collapsible-content {
            max-height: 500px; /* Large enough to show content */
            overflow: hidden;
            transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out, margin 0.3s ease-in-out;
        }

        .collapsible-content.collapsed {
            max-height: 0;
            padding-top: 0 !important; /* Ensure padding collapses */
            padding-bottom: 0 !important;
            margin-top: -10px; /* Adjust to pull up following element */
            border-top: none; /* Hide border if any was applied when open */
        }


        /* Labels for Controls */
        #controlsContainer label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 13px;
            color: #ccc;
        }

        /* Select Dropdowns */
        #controlsContainer select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #333;
            color: #fff;
            font-size: 13px;
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
        }

        /* Checkboxes */
        #controlsContainer input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle;
        }

        #controlsContainer .checkbox-label { /* Label next to a checkbox */
            display: inline-block;
            vertical-align: middle;
            font-weight: normal;
            color: #eee;
            cursor: pointer; /* Make the text label clickable for the checkbox */
        }

        /* Satellite Info Panel */
        #satelliteInfo {
            margin-top: 10px;
            color: #fff;
            font-family: monospace;
            background-color: #222;
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            white-space: pre-wrap; /* Preserve whitespace and newlines */
            border: 1px solid #444;
            max-height: 200px; /* Limit height and enable scroll if needed */
            overflow-y: auto;
        }

        /* Satellite Count Display */
        #satelliteCountDisplay {
            font-size: 13px;
            color: #00aaff;
            font-weight: bold;
        }

        /* Mercator Map Styling */
        #mercatorContainer {
            position: absolute;
            display: none; /* Hidden by default, JS controls visibility */
            pointer-events: auto; /* Allow interaction if needed for future features like map panning */
            border: 1px solid #555;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            /* Default to corner position */
            top: 10px;
            right: 10px;
            width: 400px;
            height: 200px;
            background-color: #111; /* Fallback if background image fails */
        }

        #mercatorContainer.fullscreen {
            top: 0;
            left: 0;
            right: auto; /* Override right positioning for fullscreen */
            width: 100vw;
            height: 100vh;
            border: none; /* No border in fullscreen */
            box-shadow: none; /* No shadow in fullscreen */
            z-index: 900; /* Below controls but above 3D canvas if it were visible */
        }

        .mapBackground {
            position: relative;
            width: 100%; /* Takes full width of its parent (#mercatorContainer) */
            height: 100%; /* Takes full height of its parent */
            background-color: #2a2a2a; /* Default background if no image loads */
            background-repeat: no-repeat;
            background-size: 100% 100%; /* Ensure it covers the area */
        }

        #mercatorCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .mapBackground.fallback-css {
            background: #333 url('https://placehold.co/400x200/222222/ffffff?text=Map+Load+Error') no-repeat center center !important;
            background-size: contain !important;
        }

        #mercatorContainer.fullscreen .mapBackground.fallback-css {
            background: #333 url('https://placehold.co/1920x1080/222222/ffffff?text=Map+Load+Error+Fullscreen') no-repeat center center !important;
            background-size: contain !important;
        }

        /* Styles for 3D Overlay Labels (ECEF Axes, North Pole, Equator, Meridian) */
        .axis-label {
            position: absolute;
            color: #00ff00; /* Green to match axes and lines */
            font-size: 12px;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background */
            padding: 2px 5px;
            border-radius: 3px;
            pointer-events: none; /* So they don't interfere with mouse controls */
            transform: translate(-50%, -100%); /* Position top-center of the point */
            white-space: nowrap;
            display: none; /* Hidden by default, JS will manage visibility */
            z-index: 10; /* Ensure they are above the 3D canvas but below UI controls */
        }

        /* CSS2DObject labels for detailed satellite models */
        .label {
            color: #FFF;
            font-family: sans-serif;
            padding: 2px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
        }

    </style>
    <script src="https://unpkg.com/satellite.js@4.0.0/dist/satellite.min.js"></script>
    <script type="importmap">
        {
          "imports": {
        "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
      }
        }
    </script>
</head>
<body>
<button id="menuToggleBtn">✕</button>
<div id="controlsContainer">
    <div id="versionDisplay"></div>
    <div class="control-group">
        <h3 data-collapsible-target="filtersContent">Filters <span class="toggle-icon">▾</span></h3>
        <div id="filtersContent" class="collapsible-content">
            <label for="orbitTypeFilter">Orbit Type:</label>
            <select id="orbitTypeFilter">
                <option value="ALL">ALL</option>
                <option value="LEO">LEO</option>
                <option value="MEO">MEO</option>
                <option value="GEO">GEO</option>
            </select>

            <label for="companyFilter">Company:</label>
            <select id="companyFilter">
                <option value="ALL COMPANY">ALL COMPANY</option>
            </select>

            <p>Satellites Found: <span id="satelliteCountDisplay">0</span></p>
        </div>
    </div>

    <div class="control-group">
        <h3 data-collapsible-target="viewContent">View <span class="toggle-icon">▾</span></h3>
        <div id="viewContent" class="collapsible-content">
            <input type="checkbox" id="view3DToggle" checked>
            <label for="view3DToggle" class="checkbox-label">3D Globe</label>
            <br>
            <input type="checkbox" id="viewMercatorToggle">
            <label for="viewMercatorToggle" class="checkbox-label">2D Mercator</label>
            <br>
            <input type="checkbox" id="highDefToggle">
            <label for="highDefToggle" class="checkbox-label">High Definition</label>
            <br>
            <input type="checkbox" id="showECEFAxesToggle">
            <label for="showECEFAxesToggle" class="checkbox-label">Show ECEF Axes</label>
        </div>
    </div>

    <div class="control-group">
        <h3 data-collapsible-target="orbitExtrasContent">Orbit/Extras <span class="toggle-icon">▾</span></h3>
        <div id="orbitExtrasContent" class="collapsible-content">
            <input type="checkbox" id="showOrbitToggle">
            <label for="showOrbitToggle" class="checkbox-label">Show Orbit</label>
        </div>
    </div>

    <div class="control-group">
        <h3>Satellite Selection</h3>
        <div>
            <label for="satelliteSelect">Select Satellite:</label>
            <select id="satelliteSelect">
                <option value="None">None</option>
            </select>
            <div id="satelliteInfo">
                <div style="font-weight:bold;">No satellite selected</div>
            </div>
        </div>
    </div>
</div>

<div id="mercatorContainer">
    <div class="mapBackground">
        <canvas id="mercatorCanvas"></canvas>
    </div>
</div>

<div id="labelXecr" class="axis-label">X<sub>ecr</sub></div>
<div id="labelYecr" class="axis-label">Y<sub>ecr</sub></div>
<div id="labelZecr" class="axis-label">Z<sub>ecr</sub></div>
<div id="labelNorthPole" class="axis-label">North Pole</div>
<div id="labelEquatorLine" class="axis-label">Equator Line</div>
<div id="labelGreenwichMeridian" class="axis-label">Greenwich Meridian Line:</div>


<script type="module">
    import * as THREE_Module from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
    import {
        CSS2DRenderer as CSS2DRenderer_Module,
        CSS2DObject as CSS2DObject_Module
    } from 'three/addons/renderers/CSS2DRenderer.js';

    window.THREE = THREE_Module;
    window.CSS2DObject = CSS2DObject_Module;


    const versionNumber = "1.0";
    const versionRepoUrl = "https://github.com/arcazj/openbexi_earth_orbit";
    const versionText = `version ${versionNumber} - hosted at`;

    let GITHUB_REPO_RAW_BASE_URL = "https://raw.githubusercontent.com/arcazj/openbexi_earth_orbit/master/";
    let CONFIG_BASE_URL = GITHUB_REPO_RAW_BASE_URL + "config/";
    let TLE_BASE_URL = GITHUB_REPO_RAW_BASE_URL + "json/tle/";
    // window.SATELLITE_MODELS_BASE_URL will be set after loadConfigs
    // window.TEXTURES_BASE_URL_MODULE will be set after loadConfigs

    let usingLocalAssets = false;

    let scene, camera, renderer, earthMesh, controls;
    let labelRenderer;
    let earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig;
    let globalScale;
    let mercatorCtx, mapWidth = 400, mapHeight = 200;
    let satellites = [];
    let orbitLine = null;
    let currentSelectedSatellite = null;
    let detailedSatelliteModel = null;
    let textureLoader;
    let mercatorSatIcon = new Image();
    let mercatorSatIconLoaded = false;
    let ecefXAxisHelper, ecefYAxisHelper, ecefZAxisHelper;
    let equatorLineMesh, greenwichMeridianLineMesh;

    const simParams = {
        orbitTypeFilter: "MEO",
        companyFilter: "ALL COMPANY",
        selectedSatellite: "None",
        showOrbit: false,
        view3D: true,
        viewMercator: false,
        useHighDefTexture: false,
        showECEFAxes: false
    };

    let orbitTypeFilterSelect, companyFilterSelect, satelliteCountDisplay;
    let view3DToggle, viewMercatorToggle, showOrbitToggle, highDefToggleElement, showECEFAxesToggleElement;
    let satelliteSelectDropdown, satelliteInfoDiv;
    let mercatorContainer, mercatorCanvasElement, mapBackgroundDiv;
    let controlsContainerElement, menuToggleBtnElement, versionDisplayElement;
    let labelXecrDiv, labelYecrDiv, labelZecrDiv, labelNorthPoleDiv, labelEquatorLineDiv, labelGreenwichMeridianDiv;

    const EARTH_RADIUS_KM = 6371;
    const EARTH_SCENE_RADIUS = 10;
    window.KM_TO_SCENE_UNITS = EARTH_SCENE_RADIUS / EARTH_RADIUS_KM;
    window.METERS_TO_SCENE_UNITS = window.KM_TO_SCENE_UNITS / 1000;


    // --- Satellite Model Loader Module (IIFE) ---
    (function (global) {
        "use strict";

        const THREE_Instance = global.THREE;
        const CSS2DObject_Instance = global.CSS2DObject;

        if (!THREE_Instance) {
            console.error("satelliteModelLoader (IIFE): THREE.js not found on window. Loader disabled.");
            global.satelliteModelLoader = {
                showSatellite: async () => null, clearCurrentDetailedSat: () => {
                }
            };
            return;
        }

        const _foilTextureCache = new Map();
        const _solarTextureCache = new Map();

        function generateFoilTexture(repeat = 4) {
            if (_foilTextureCache.has(repeat)) return _foilTextureCache.get(repeat);
            const size = 512;
            const canvas = document.createElement("canvas");
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext("2d");
            const img = ctx.createImageData(size, size);
            for (let i = 0; i < img.data.length; i += 4) {
                const v = Math.random() * 150 + 80;
                img.data[i] = img.data[i + 1] = img.data[i + 2] = v;
                img.data[i + 3] = 255;
            }
            ctx.putImageData(img, 0, 0);
            const tex = new THREE_Instance.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE_Instance.RepeatWrapping;
            tex.repeat.set(repeat, repeat);
            if (global.renderer) tex.anisotropy = global.renderer.capabilities.getMaxAnisotropy();
            _foilTextureCache.set(repeat, tex);
            return tex;
        }

        function loadSolarTexture(repeat = 3) {
            if (_solarTextureCache.has(repeat)) return _solarTextureCache.get(repeat);
            const panelPath = global.getFullGitHubUrl("textures/solar_panel_cells.png");
            let tex;
            if (panelPath) {
                tex = new THREE_Instance.TextureLoader().load(
                    panelPath, () => void 0, undefined,
                    err => {
                        console.error("satelliteModelLoader: failed to load solar‑panel texture", panelPath, err);
                    }
                );
            } else {
                const s = 64, c = document.createElement("canvas");
                c.width = c.height = s;
                const cx = c.getContext("2d");
                cx.fillStyle = "#2222AA";
                cx.fillRect(0, 0, s, s);
                cx.strokeStyle = "#5555FF";
                for (let i = 0; i < s; i += 8) {
                    cx.strokeRect(i, 0, 8, s);
                    cx.strokeRect(0, i, s, 8);
                }
                tex = new THREE_Instance.CanvasTexture(c);
            }
            tex.wrapS = tex.wrapT = THREE_Instance.RepeatWrapping;
            tex.repeat.set(repeat, repeat);
            if (global.renderer) tex.anisotropy = global.renderer.capabilities.getMaxAnisotropy();
            _solarTextureCache.set(repeat, tex);
            return tex;
        }

        function orient(object, dir, axisY = true) {
            const R = Math.PI / 2;
            switch (dir) {
                case "west":
                    axisY ? object.rotateZ(R) : object.rotateY(R);
                    break;
                case "east":
                    axisY ? object.rotateZ(-R) : object.rotateY(-R);
                    break;
                case "north":
                    axisY ? object.rotateX(R) : null;
                    break;
                case "south":
                    axisY ? object.rotateX(-R) : object.rotateY(Math.PI);
                    break;
                case "down":
                    axisY && object.rotateX(Math.PI);
                    break;
            }
        }

        function buildBus(bus, tex) {
            return new THREE_Instance.Mesh(
                new THREE_Instance.BoxGeometry(
                    bus.width_m * global.METERS_TO_SCENE_UNITS,
                    bus.height_m * global.METERS_TO_SCENE_UNITS,
                    bus.depth_m * global.METERS_TO_SCENE_UNITS
                ),
                new THREE_Instance.MeshPhongMaterial({map: tex.foil, color: 0xffffff, shininess: 80})
            );
        }

        function buildPanels(list, tex) {
            const group = new THREE_Instance.Group();
            const mat = new THREE_Instance.MeshBasicMaterial({map: tex.panel, side: THREE_Instance.DoubleSide});
            list.forEach(p => {
                const panel = new THREE_Instance.Mesh(
                    new THREE_Instance.PlaneGeometry(
                        p.length_m * global.METERS_TO_SCENE_UNITS,
                        p.width_m * global.METERS_TO_SCENE_UNITS
                    ), mat);
                panel.position.set(...p.position_m.map(v => v * global.METERS_TO_SCENE_UNITS));
                orient(panel, p.orientation, false);
                group.add(panel);
            });
            return group;
        }

        function buildAntennas(list, labelsRef) {
            const group = new THREE_Instance.Group();
            const dishMat = new THREE_Instance.MeshPhongMaterial({
                color: 0xd8a65d,
                side: THREE_Instance.DoubleSide,
                shininess: 35
            });
            const ttMat = new THREE_Instance.MeshPhongMaterial({color: 0xcccccc});
            list.forEach(a => {
                let mesh;
                const R = a.radius_m * global.METERS_TO_SCENE_UNITS;
                if (a.type === "dish") {
                    const D = a.depth_m * global.METERS_TO_SCENE_UNITS;
                    const prof = [new THREE_Instance.Vector2(R, 0), new THREE_Instance.Vector2(0.8 * R, 0.5 * D), new THREE_Instance.Vector2(0.3 * R, 0.8 * D), new THREE_Instance.Vector2(0, D)];
                    mesh = new THREE_Instance.Mesh(new THREE_Instance.LatheGeometry(prof, 32), dishMat);
                } else {
                    mesh = new THREE_Instance.Mesh(new THREE_Instance.SphereGeometry(R, 16, 8), ttMat);
                }
                mesh.position.set(...a.position_m.map(v => v * global.METERS_TO_SCENE_UNITS));
                if (a.orientation) orient(mesh, a.orientation, true);
                if (a.tilt_deg) mesh.rotateZ(THREE_Instance.MathUtils.degToRad(a.tilt_deg) * (a.orientation === "west" ? 1 : -1));
                if (CSS2DObject_Instance) {
                    const div = document.createElement("div");
                    div.className = "label";
                    div.textContent = a.band === "TT&C" ? "TT&C" : `${a.band}-band`;
                    const lbl = new CSS2DObject_Instance(div);
                    lbl.position.set(0, R * 1.2, 0);
                    mesh.add(lbl);
                    labelsRef.push(lbl);
                }
                group.add(mesh);
            });
            return group;
        }

        function buildThrusters(list) {
            const group = new THREE_Instance.Group();
            const mat = new THREE_Instance.MeshPhongMaterial({color: 0x444444});
            list.forEach(t => {
                let mesh;
                const H = t.height_m * global.METERS_TO_SCENE_UNITS;
                if (t.type === "cylinder") {
                    const R_thruster = t.radius_m * global.METERS_TO_SCENE_UNITS;
                    mesh = new THREE_Instance.Mesh(new THREE_Instance.CylinderGeometry(R_thruster, R_thruster, H, 16), mat);
                } else {
                    const Rb = t.radius_bottom_m * global.METERS_TO_SCENE_UNITS;
                    mesh = new THREE_Instance.Mesh(new THREE_Instance.ConeGeometry(Rb, H, 16), mat);
                    mesh.rotateX(Math.PI);
                }
                mesh.position.set(...t.position_m.map(v => v * global.METERS_TO_SCENE_UNITS));
                if (t.orientation) orient(mesh, t.orientation, true);
                group.add(mesh);
            });
            return group;
        }

        function buildSatellite(geom, textures, labelsRef) {
            const sat = new THREE_Instance.Group();
            if (geom.bus) sat.add(buildBus(geom.bus, textures));
            if (geom.solar_panels) sat.add(buildPanels(geom.solar_panels, textures));
            if (geom.antennas) sat.add(buildAntennas(geom.antennas, labelsRef));
            if (geom.thrusters) sat.add(buildThrusters(geom.thrusters));
            return sat;
        }

        const modelLoaderSingleton = {
            currentSatModel: null,
            currentLabels: [],
            async showSatellite(noradId, mainScene) {
                if (this.currentSatModel) {
                    mainScene.remove(this.currentSatModel);
                    this.currentLabels.forEach(l => l.parent && l.parent.remove(l));
                    this.currentLabels.length = 0;
                    this.currentSatModel = null;
                }
                const modelUrl = (global.SATELLITE_MODELS_BASE_URL || "json/satellites/") + `${noradId}.json`;
                console.log(`[satelliteModelLoader] Fetching model:`, modelUrl);
                try {
                    const data = await global.fetchJSON(modelUrl);
                    if (!data || !data[noradId] || !data[noradId].geometry) {
                        console.warn(`[satelliteModelLoader] No geometry for NORAD ${noradId} at ${modelUrl}`);
                        return null;
                    }
                    const geom = data[noradId].geometry;
                    const textures = {foil: generateFoilTexture(4), panel: loadSolarTexture(3)};
                    this.currentSatModel = buildSatellite(geom, textures, this.currentLabels);
                    this.currentSatModel.userData = {noradId, sourceData: data[noradId]};
                    mainScene.add(this.currentSatModel);
                    return this.currentSatModel;
                } catch (err) {
                    console.error(`[satelliteModelLoader] Failed to load model for NORAD ${noradId}:`, err);
                    return null;
                }
            },
            clearCurrentDetailedSat(mainScene) {
                if (this.currentSatModel) {
                    mainScene.remove(this.currentSatModel);
                    this.currentLabels.forEach(l => l.parent && l.parent.remove(l));
                    this.currentLabels.length = 0;
                    this.currentSatModel = null;
                }
            }
        };
        global.satelliteModelLoader = modelLoaderSingleton;
    })(window);

    // --- End of Satellite Model Loader Module ---


    function getFullGitHubUrl(relativePath) {
        if (!relativePath || typeof relativePath !== 'string') {
            console.warn("getFullGitHubUrl: received invalid path:", relativePath);
            return usingLocalAssets ? relativePath.replace(/^\//, '') : null;
        }
        if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
            return relativePath;
        }
        if (usingLocalAssets) {
            return relativePath.replace(/^\//, '');
        }
        return GITHUB_REPO_RAW_BASE_URL + relativePath.replace(/^\//, '');
    }

    window.getFullGitHubUrl = getFullGitHubUrl;

    function fetchJSON(url) {
        return fetch(url).then(resp => {
            if (!resp.ok) throw new Error(`Failed to load ${url}: ${resp.statusText} (Status: ${resp.status})`);
            return resp.json();
        }).catch(error => {
            console.error(`Error fetching JSON from ${url}:`, error.message);
            if (url.includes('/tle/')) return [];
            return {};
        });
    }

    window.fetchJSON = fetchJSON;


    function isMobileDevice() {
        return /Android|iPhone|iPad|iPod|BlackBerry|Windows Phone/i.test(navigator.userAgent || navigator.vendor || window.opera);
    }

    async function loadConfigs() {
        console.log("Attempting to load configurations from GitHub:", CONFIG_BASE_URL);
        let primaryLoadSuccess = false;
        try {
            const results = await Promise.all([
                fetchJSON(CONFIG_BASE_URL + 'earth.json'),
                fetchJSON(CONFIG_BASE_URL + 'constants.json'),
                fetchJSON(CONFIG_BASE_URL + 'satellite.json'),
                fetchJSON(CONFIG_BASE_URL + 'scene.json'),
                fetchJSON(CONFIG_BASE_URL + 'controls.json')
            ]);
            [earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig] = results;

            if (!earthConfig || Object.keys(earthConfig).length === 0) {
                throw new Error("GitHub config load resulted in empty critical config (e.g., earth.json).");
            }
            console.log("Configurations loaded successfully from GitHub.");
            window.SATELLITE_MODELS_BASE_URL = GITHUB_REPO_RAW_BASE_URL + "json/satellites/";
            window.TEXTURES_BASE_URL_MODULE = GITHUB_REPO_RAW_BASE_URL + "textures/";
            primaryLoadSuccess = true;

        } catch (githubError) {
            console.warn("GitHub configuration load failed:", githubError.message, "Attempting local fallback.");
            usingLocalAssets = true;
            GITHUB_REPO_RAW_BASE_URL = "";
            CONFIG_BASE_URL = "config/";
            TLE_BASE_URL = "json/tle/";
            window.SATELLITE_MODELS_BASE_URL = "json/satellites/";
            window.TEXTURES_BASE_URL_MODULE = "textures/";

            try {
                const results = await Promise.all([
                    fetchJSON(CONFIG_BASE_URL + 'earth.json'),
                    fetchJSON(CONFIG_BASE_URL + 'constants.json'),
                    fetchJSON(CONFIG_BASE_URL + 'satellite.json'),
                    fetchJSON(CONFIG_BASE_URL + 'scene.json'),
                    fetchJSON(CONFIG_BASE_URL + 'controls.json')
                ]);
                [earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig] = results;

                if (!earthConfig || Object.keys(earthConfig).length === 0) {
                    throw new Error("Local config load also resulted in empty critical config.");
                }
                console.log("Configurations loaded successfully from local fallback.");
                primaryLoadSuccess = true;
            } catch (localError) {
                console.error("Both GitHub and local configuration loads failed:", localError.message, "Using hardcoded fallbacks.");
            }
        }

        if (!primaryLoadSuccess) {
            earthConfig = {
                diameter: EARTH_RADIUS_KM * 2,
                texture: 'textures/1_earth_16k.jpg',
                textureLight: 'textures/earthmap1k_light.jpg'
            };
            satelliteConfig = {
                icon: 'icons/ob_satellite.png',
                scale: [0.1, 0.1, 0.1],
                mercatorIcon: 'icons/ob_satellite.png'
            };
            sceneConfig = {
                camera: {fov: 45, near: 0.1, far: 1000, position: [0, 0, 30]},
                ambientLight: {color: 0xffffff, intensity: 0.5},
                directionalLight: {color: 0xffffff, intensity: 1, position: [5, 3, 5]}
            };
            controlsConfig = {enableDamping: true, dampingFactor: 0.05};
            constantsConfig = {};
            window.SATELLITE_MODELS_BASE_URL = "json/satellites/";
            window.TEXTURES_BASE_URL_MODULE = "textures/";
            alert("Error loading configurations from all sources. Using default settings. App functionality may be limited.");
        }

        earthConfig.diameter = earthConfig.diameter || EARTH_RADIUS_KM * 2;
        earthConfig.texture = earthConfig.texture || 'textures/1_earth_16k.jpg';
        earthConfig.textureLight = earthConfig.textureLight || 'textures/earthmap1k_light.jpg';
        satelliteConfig.icon = satelliteConfig.icon || 'icons/ob_satellite.png';
        satelliteConfig.scale = satelliteConfig.scale || [0.1, 0.1, 0.1];
        satelliteConfig.mercatorIcon = satelliteConfig.mercatorIcon || 'icons/ob_satellite.png';
        sceneConfig.camera = sceneConfig.camera || {fov: 45, near: 0.1, far: 1000, position: [0, 0, 30]};
        sceneConfig.ambientLight = sceneConfig.ambientLight || {color: 0xffffff, intensity: 0.5};
        sceneConfig.directionalLight = sceneConfig.directionalLight || {
            color: 0xffffff,
            intensity: 1,
            position: [5, 3, 5]
        };
        controlsConfig.enableDamping = controlsConfig.enableDamping !== undefined ? controlsConfig.enableDamping : true;
        controlsConfig.dampingFactor = controlsConfig.dampingFactor || 0.05;

        globalScale = (earthConfig.diameter / 2) / EARTH_SCENE_RADIUS;
    }

    function updateEarthTexture() {
        if (!earthMesh || !textureLoader || !earthConfig) {
            console.warn("updateEarthTexture: Missing critical components.");
            return;
        }

        const hdTextureFullUrl = getFullGitHubUrl(earthConfig.texture);
        const lightTextureFullUrl = getFullGitHubUrl(earthConfig.textureLight);
        const textureToLoad = simParams.useHighDefTexture ? hdTextureFullUrl : lightTextureFullUrl;

        if (!textureToLoad) {
            console.error("Earth Texture URL is null. Check config paths.");
            earthMesh.material.map = null;
            earthMesh.material.color.set(0x1a237e);
            earthMesh.material.needsUpdate = true;
            return;
        }
        console.log("Attempting to load Earth texture:", textureToLoad);

        textureLoader.load(textureToLoad,
            (texture) => {
                earthMesh.material.map = texture;
                earthMesh.material.color.set(0xffffff);
                earthMesh.material.needsUpdate = true;
                console.log("Earth texture successfully updated to:", textureToLoad);
            },
            undefined,
            (err) => {
                console.error('Error loading Earth texture from:', textureToLoad, err, '. Using placeholder.');
                const fallbackPlaceholder = `https://placehold.co/${simParams.useHighDefTexture ? '4096x2048' : '1024x512'}/1c313a/ffffff?text=Earth+Load+Error`;
                textureLoader.load(fallbackPlaceholder, (fallbackMap) => {
                    earthMesh.material.map = fallbackMap;
                    earthMesh.material.needsUpdate = true;
                });
            }
        );
    }

    function updateECEFAxesVisibility() {
        const visible = simParams.showECEFAxes;
        if (ecefXAxisHelper) ecefXAxisHelper.visible = visible;
        if (ecefYAxisHelper) ecefYAxisHelper.visible = visible;
        if (ecefZAxisHelper) ecefZAxisHelper.visible = visible;
        if (equatorLineMesh) equatorLineMesh.visible = visible;
        if (greenwichMeridianLineMesh) greenwichMeridianLineMesh.visible = visible;

        if (labelXecrDiv) labelXecrDiv.style.display = visible ? 'block' : 'none';
        if (labelYecrDiv) labelYecrDiv.style.display = visible ? 'block' : 'none';
        if (labelZecrDiv) labelZecrDiv.style.display = visible ? 'block' : 'none';
        if (labelNorthPoleDiv) labelNorthPoleDiv.style.display = visible ? 'block' : 'none';
        if (labelEquatorLineDiv) labelEquatorLineDiv.style.display = visible ? 'block' : 'none';
        if (labelGreenwichMeridianDiv) labelGreenwichMeridianDiv.style.display = visible ? 'block' : 'none';
    }

    function init3D() {
        scene = new THREE_Module.Scene();
        camera = new THREE_Module.PerspectiveCamera(sceneConfig.camera.fov, window.innerWidth / window.innerHeight, sceneConfig.camera.near, sceneConfig.camera.far);
        camera.position.set(...sceneConfig.camera.position);
        renderer = new THREE_Module.WebGLRenderer({antialias: true});
        window.renderer = renderer;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        labelRenderer = new CSS2DRenderer_Module();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.left = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);


        scene.add(new THREE_Module.AmbientLight(sceneConfig.ambientLight.color, sceneConfig.ambientLight.intensity));
        const dirLight = new THREE_Module.DirectionalLight(sceneConfig.directionalLight.color, sceneConfig.directionalLight.intensity);
        dirLight.position.set(...sceneConfig.directionalLight.position);
        scene.add(dirLight);

        textureLoader = new THREE_Module.TextureLoader();
        const earthMat = new THREE_Module.MeshPhongMaterial({color: 0xffffff});
        earthMesh = new THREE_Module.Mesh(new THREE_Module.SphereGeometry(EARTH_SCENE_RADIUS, 64, 64), earthMat);
        scene.add(earthMesh);

        updateEarthTexture();

        const TARGET_AXIS_LENGTH_KM = 400;
        const visualAxisExtentInSceneUnits = TARGET_AXIS_LENGTH_KM * KM_TO_SCENE_UNITS;

        const headLength = Math.max(0.1, visualAxisExtentInSceneUnits * 0.25);
        const headWidth = headLength * 0.5;
        const arrowHelperLineLength = Math.max(0.01, visualAxisExtentInSceneUnits - headLength);
        const ecefAxisColor = 0x00ff00;

        ecefXAxisHelper = new THREE_Module.ArrowHelper(new THREE_Module.Vector3(1, 0, 0), new THREE_Module.Vector3(0, 0, 0), arrowHelperLineLength, ecefAxisColor, headLength, headWidth);
        scene.add(ecefXAxisHelper);

        ecefYAxisHelper = new THREE_Module.ArrowHelper(new THREE_Module.Vector3(0, 0, 1), new THREE_Module.Vector3(0, 0, 0), arrowHelperLineLength, ecefAxisColor, headLength, headWidth);
        scene.add(ecefYAxisHelper);

        ecefZAxisHelper = new THREE_Module.ArrowHelper(new THREE_Module.Vector3(0, 1, 0), new THREE_Module.Vector3(0, 0, 0), arrowHelperLineLength, ecefAxisColor, headLength, headWidth);
        scene.add(ecefZAxisHelper);

        const equatorRadius = EARTH_SCENE_RADIUS + 0.05;
        const graticuleMaterial = new THREE_Module.LineBasicMaterial({color: 0x00ff00});
        const equatorGeometry = new THREE_Module.BufferGeometry().setFromPoints(
            new THREE_Module.Path().absarc(0, 0, equatorRadius, 0, Math.PI * 2, false).getPoints(64)
        );
        equatorLineMesh = new THREE_Module.Line(equatorGeometry, graticuleMaterial);
        equatorLineMesh.rotation.x = Math.PI / 2;
        equatorLineMesh.userData.radius = equatorRadius;
        scene.add(equatorLineMesh);

        const meridianPoints = [];
        const meridianSegments = 32;
        for (let i = 0; i <= meridianSegments; i++) {
            const phi = (i / meridianSegments) * Math.PI;
            meridianPoints.push(new THREE_Module.Vector3(Math.sin(phi) * equatorRadius, Math.cos(phi) * equatorRadius, 0));
        }
        const meridianGeometry = new THREE_Module.BufferGeometry().setFromPoints(meridianPoints);
        greenwichMeridianLineMesh = new THREE_Module.Line(meridianGeometry, graticuleMaterial);
        scene.add(greenwichMeridianLineMesh);

        updateECEFAxesVisibility();

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = controlsConfig.enableDamping;
        controls.dampingFactor = controlsConfig.dampingFactor;
        controls.minDistance = EARTH_SCENE_RADIUS * 1.2;
        controls.maxDistance = EARTH_SCENE_RADIUS * 15;
    }

    function initMercatorView() {
        mercatorContainer = document.getElementById("mercatorContainer");
        mapBackgroundDiv = mercatorContainer.querySelector(".mapBackground");
        mercatorCanvasElement = document.getElementById("mercatorCanvas");

        mapWidth = mapBackgroundDiv.clientWidth;
        mapHeight = mapBackgroundDiv.clientHeight;
        mercatorCanvasElement.width = mapWidth;
        mercatorCanvasElement.height = mapHeight;
        mercatorCtx = mercatorCanvasElement.getContext("2d");

        const remoteMapBgUrl = getFullGitHubUrl('textures/earthmap1k.jpg');

        if (remoteMapBgUrl) {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                mapBackgroundDiv.style.backgroundImage = `url(${remoteMapBgUrl})`;
                mapBackgroundDiv.classList.remove('fallback-css');
                console.log("Mercator map background texture loaded:", remoteMapBgUrl);
            };
            img.onerror = () => {
                console.warn(`Mercator map background '${remoteMapBgUrl}' failed. Applying CSS fallback.`);
                mapBackgroundDiv.classList.add('fallback-css');
            };
            img.src = remoteMapBgUrl;
        } else {
            console.warn("Mercator map background URL is null. Applying CSS fallback.");
            mapBackgroundDiv.classList.add('fallback-css');
        }

        const mercatorIconFullUrl = getFullGitHubUrl(satelliteConfig.mercatorIcon || 'icons/ob_satellite.png');
        if (mercatorIconFullUrl) {
            mercatorSatIcon.crossOrigin = "Anonymous";
            mercatorSatIcon.onload = () => {
                mercatorSatIconLoaded = true;
                console.log("Mercator satellite icon loaded from:", mercatorSatIcon.src);
            };
            mercatorSatIcon.onerror = () => {
                console.error("Mercator satellite icon failed to load from:", mercatorIconFullUrl, ". Using placeholder.");
                mercatorSatIcon.src = 'https://placehold.co/16x16/ffffff/000000?text=S';
                mercatorSatIcon.onload = () => {
                    mercatorSatIconLoaded = true;
                };
            };
            mercatorSatIcon.src = mercatorIconFullUrl;
        } else {
            console.error("Mercator satellite icon path is null. Using placeholder.");
            mercatorSatIcon.src = 'https://placehold.co/16x16/ffffff/000000?text=S';
            mercatorSatIcon.onload = () => {
                mercatorSatIconLoaded = true;
            };
        }
    }

    async function setupTLESatellites() {
        console.log("Attempting to load TLE data from:", TLE_BASE_URL);
        const primaryTleUrl = TLE_BASE_URL + 'TLE.json';

        try {
            let tleData = await fetchJSON(primaryTleUrl);

            if (!Array.isArray(tleData) || tleData.length === 0) {
                console.warn(`TLE data from ${primaryTleUrl} failed or is empty.`);
                if (usingLocalAssets) {
                    alert("Critical Error: Failed to load any satellite TLE data (local attempt also failed). Satellites will not be displayed.");
                } else {
                    const backupTleUrl = (GITHUB_REPO_RAW_BASE_URL || "") + "json/tle/" + 'TLE_backup.json';
                    console.log("Attempting backup TLE from:", backupTleUrl);
                    tleData = await fetchJSON(backupTleUrl);
                    if (!Array.isArray(tleData) || tleData.length === 0) {
                        alert("Critical Error: Failed to load any satellite TLE data from primary or backup. Satellites will not be displayed.");
                    } else {
                        console.log("Loaded TLE data from backup source.");
                    }
                }
                if (!Array.isArray(tleData) || tleData.length === 0) {
                    processSatellites([], null);
                    return;
                }
            }

            const satIconFullUrl = getFullGitHubUrl(satelliteConfig.icon || 'icons/ob_satellite.png');
            let satMaterial;

            if (!satIconFullUrl) {
                console.error("3D Satellite icon path is null. Using placeholder material.");
                satMaterial = new THREE_Module.SpriteMaterial({
                    map: textureLoader.load('https://placehold.co/32x32/ff0000/ffffff?text=S_ERR')
                });
            } else {
                satMaterial = new THREE_Module.SpriteMaterial({
                    map: textureLoader.load(satIconFullUrl, undefined,
                        () => {
                            console.log("3D Satellite icon loaded from:", satIconFullUrl);
                        },
                        (err) => {
                            console.error('Error loading 3D satellite icon from:', satIconFullUrl, err, '. Using placeholder.');
                            if (satMaterial) {
                                satMaterial.map = textureLoader.load('https://placehold.co/32x32/ff0000/ffffff?text=S');
                                satMaterial.needsUpdate = true;
                            }
                        })
                });
            }
            processSatellites(tleData, satMaterial);

        } catch (err) {
            console.error("Error in setupTLESatellites (fetching/processing):", err);
            alert("Error setting up satellite data. Check console.");
            processSatellites([], null);
        }
    }

    function processSatellites(tleData, baseMaterial) {
        satellites.forEach(s => {
            if (s.mesh) scene.remove(s.mesh);
        });
        satellites.length = 0;

        if (!tleData || tleData.length === 0) {
            console.warn("No TLE data to process.");
            if (typeof updateSatelliteList === "function") updateSatelliteList();
            return;
        }
        if (!baseMaterial) {
            console.error("Base material for satellites is not available. Cannot create sprites.");
            if (typeof updateSatelliteList === "function") updateSatelliteList();
            return;
        }

        tleData.forEach(item => {
            const {company, satellite_name, norad_id, type, launch_date, tle_line1, tle_line2} = item;
            if (!tle_line1 || !tle_line2) {
                console.warn(`Skipping ${satellite_name || norad_id}: missing TLE lines.`);
                return;
            }
            try {
                const satrec = satellite.twoline2satrec(tle_line1, tle_line2);
                if (!satrec) throw new Error("Failed to parse TLE.");

                const sprite = new THREE_Module.Sprite(baseMaterial.clone());
                sprite.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
                scene.add(sprite);
                satellites.push({
                    mesh: sprite, satrec,
                    orbitType: type || "N/A",
                    company: company || "N/A",
                    satellite_name: satellite_name || `NORAD ${norad_id}`,
                    norad_id, launch_date, tle_line1, tle_line2
                });
            } catch (e) {
                console.error(`Error processing TLE for ${satellite_name || norad_id}: ${e.message}.`);
            }
        });
        console.log(`${satellites.length} satellites processed.`);
        if (typeof updateSatelliteList === "function") updateSatelliteList();
    }

    function setupHTMLControls() {
        controlsContainerElement = document.getElementById('controlsContainer');
        menuToggleBtnElement = document.getElementById('menuToggleBtn');
        versionDisplayElement = document.getElementById('versionDisplay');

        if (versionDisplayElement) {
            const versionLink = document.createElement('a');
            versionLink.href = versionRepoUrl;
            versionLink.textContent = `GitHub Repo`;
            versionLink.target = "_blank";
            versionDisplayElement.textContent = `${versionText} `;
            versionDisplayElement.appendChild(versionLink);
        }

        orbitTypeFilterSelect = document.getElementById('orbitTypeFilter');
        companyFilterSelect = document.getElementById('companyFilter');
        satelliteCountDisplay = document.getElementById('satelliteCountDisplay');
        view3DToggle = document.getElementById('view3DToggle');
        viewMercatorToggle = document.getElementById('viewMercatorToggle');
        highDefToggleElement = document.getElementById('highDefToggle');
        showECEFAxesToggleElement = document.getElementById('showECEFAxesToggle');
        showOrbitToggle = document.getElementById('showOrbitToggle');
        satelliteSelectDropdown = document.getElementById('satelliteSelect');
        satelliteInfoDiv = document.getElementById('satelliteInfo');

        labelXecrDiv = document.getElementById('labelXecr');
        labelYecrDiv = document.getElementById('labelYecr');
        labelZecrDiv = document.getElementById('labelZecr');
        labelNorthPoleDiv = document.getElementById('labelNorthPole');
        labelEquatorLineDiv = document.getElementById('labelEquatorLine');
        labelGreenwichMeridianDiv = document.getElementById('labelGreenwichMeridian');


        orbitTypeFilterSelect.value = simParams.orbitTypeFilter;
        view3DToggle.checked = simParams.view3D;
        viewMercatorToggle.checked = simParams.viewMercator;
        if (highDefToggleElement) highDefToggleElement.checked = simParams.useHighDefTexture;
        if (showECEFAxesToggleElement) showECEFAxesToggleElement.checked = simParams.showECEFAxes;
        showOrbitToggle.checked = simParams.showOrbit;

        orbitTypeFilterSelect.addEventListener('change', (e) => {
            simParams.orbitTypeFilter = e.target.value;
            simParams.showOrbit = false;
            if (showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry();
            updateSatelliteList();
        });
        companyFilterSelect.addEventListener('change', (e) => {
            simParams.companyFilter = e.target.value;
            simParams.showOrbit = false;
            if (showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry();
            updateSatelliteList();
        });
        view3DToggle.addEventListener('change', (e) => simParams.view3D = e.target.checked);
        viewMercatorToggle.addEventListener('change', (e) => simParams.viewMercator = e.target.checked);

        if (highDefToggleElement) {
            highDefToggleElement.addEventListener('change', (e) => {
                simParams.useHighDefTexture = e.target.checked;
                updateEarthTexture();
            });
        }
        if (showECEFAxesToggleElement) {
            showECEFAxesToggleElement.addEventListener('change', (e) => {
                simParams.showECEFAxes = e.target.checked;
                updateECEFAxesVisibility();
            });
        }

        showOrbitToggle.addEventListener('change', (e) => {
            simParams.showOrbit = e.target.checked;
            if (currentSelectedSatellite) updateOrbitTrajectory(currentSelectedSatellite);
            else if (simParams.showOrbit) {
                simParams.showOrbit = false;
                e.target.checked = false;
            }
        });
        satelliteSelectDropdown.addEventListener('change', handleSatelliteDropdownChange);

        document.querySelectorAll('#controlsContainer h3[data-collapsible-target]').forEach(header => {
            const targetId = header.dataset.collapsibleTarget;
            const targetContent = document.getElementById(targetId);
            const icon = header.querySelector('.toggle-icon');
            if (targetContent && icon) {
                targetContent.classList.remove('collapsed');
                icon.classList.remove('collapsed');
                icon.textContent = '▾';
                header.addEventListener('click', () => {
                    targetContent.classList.toggle('collapsed');
                    icon.classList.toggle('collapsed');
                    icon.textContent = targetContent.classList.contains('collapsed') ? '▸' : '▾';
                });
            }
        });

        if (menuToggleBtnElement && controlsContainerElement) {
            menuToggleBtnElement.addEventListener('click', () => {
                controlsContainerElement.classList.toggle('menu-hidden');
                menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕';
            });
            menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕';
        }
    }

    function updateSatelliteList() {
        if (!satellites || !satelliteSelectDropdown || !companyFilterSelect) {
            console.warn("updateSatelliteList: DOM elements not ready or satellites not loaded.");
            if (satelliteCountDisplay) satelliteCountDisplay.textContent = '0';
            if (satelliteSelectDropdown) satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
            if (companyFilterSelect) companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
            return;
        }

        const filtered = satellites.filter(s =>
            (simParams.orbitTypeFilter === "ALL" || s.orbitType === simParams.orbitTypeFilter) &&
            (simParams.companyFilter === "ALL COMPANY" || s.company === simParams.companyFilter)
        );
        satellites.forEach(s => {
            if (s.mesh) {
                const isDetailedModelForThisSat = detailedSatelliteModel && detailedSatelliteModel.userData.noradId && detailedSatelliteModel.userData.noradId.toString() === s.norad_id.toString();
                const isVisibleBasedOnFilter = filtered.includes(s);

                s.mesh.visible = isVisibleBasedOnFilter && !isDetailedModelForThisSat;

                if (isVisibleBasedOnFilter) {
                    s.mesh.material.color.set(s.isSelected ? 0xff0000 : 0xffffff);
                    s.mesh.scale.set(...(s.isSelected ? (satelliteConfig.scale || [0.1, 0.1, 0.1]).map(v => v * 1.5) : (satelliteConfig.scale || [0.1, 0.1, 0.1])));
                }
            }
        });

        if (detailedSatelliteModel && detailedSatelliteModel.userData.noradId) {
            const isDetailedSatInFilteredList = filtered.some(s => s.norad_id.toString() === detailedSatelliteModel.userData.noradId.toString());
            if (!isDetailedSatInFilteredList) {
                clearDetailedSatelliteView();
                resetCameraToDefault();
                updateSatelliteInfoPanel(null, null);
            }
        } else if (currentSelectedSatellite && !filtered.includes(currentSelectedSatellite)) {
            selectSatellite(null);
        }

        if (satelliteCountDisplay) satelliteCountDisplay.textContent = filtered.length;

        const uniqueCompanies = Array.from(new Set(satellites.map(s => s.company))).sort();
        const currentCompanySelection = companyFilterSelect.value;
        companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
        uniqueCompanies.forEach(comp => {
            if (comp) {
                const option = document.createElement('option');
                option.value = comp;
                option.textContent = comp;
                companyFilterSelect.appendChild(option);
            }
        });
        if (uniqueCompanies.includes(currentCompanySelection)) {
            companyFilterSelect.value = currentCompanySelection;
        } else if (uniqueCompanies.length > 0 && simParams.companyFilter === "ALL COMPANY") {
            companyFilterSelect.value = "ALL COMPANY";
        } else if (uniqueCompanies.length > 0) {
            companyFilterSelect.value = uniqueCompanies[0];
            simParams.companyFilter = uniqueCompanies[0];
        } else {
            companyFilterSelect.value = "ALL COMPANY";
            simParams.companyFilter = "ALL COMPANY";
        }


        const currentDropdownValue = satelliteSelectDropdown.value;
        satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
        filtered.forEach(s => {
            const option = document.createElement('option');
            option.value = s.norad_id;
            option.textContent = s.satellite_name;
            satelliteSelectDropdown.appendChild(option);
        });

        if (simParams.selectedSatellite !== "None" && filtered.some(s => s.norad_id.toString() === simParams.selectedSatellite.toString())) {
            satelliteSelectDropdown.value = simParams.selectedSatellite;
        } else {
            satelliteSelectDropdown.value = "None";
            if (simParams.selectedSatellite !== "None") {
                clearDetailedSatelliteView();
                resetCameraToDefault();
                updateSatelliteInfoPanel(null, null);
                simParams.selectedSatellite = "None";
            }
        }
    }

    async function handleSatelliteDropdownChange(event) {
        const selectedNoradId = event.target.value;

        if (detailedSatelliteModel && detailedSatelliteModel.userData.noradId) {
            const prevTleSat = satellites.find(s => s.norad_id.toString() === detailedSatelliteModel.userData.noradId.toString());
            if (prevTleSat && prevTleSat.mesh) {
                prevTleSat.mesh.visible = true;
                prevTleSat.isSelected = false;
                prevTleSat.mesh.material.color.set(0xffffff);
                prevTleSat.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
            }
        }

        clearDetailedSatelliteView();

        simParams.selectedSatellite = selectedNoradId;

        if (selectedNoradId === "None") {
            currentSelectedSatellite = null;
            updateSatelliteInfoPanel(null, null);
            resetCameraToDefault();
            satellites.forEach(s => {
                if (s.mesh) {
                    s.isSelected = false;
                    s.mesh.material.color.set(0xffffff);
                    s.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
                }
            });
            updateSatelliteList();
            return;
        }

        await loadAndDisplayDetailedSatellite(selectedNoradId);
    }

    async function loadAndDisplayDetailedSatellite(noradId) {
        console.log(`Attempting to load detailed model for NORAD ID: ${noradId}`);
        const newModel = await window.satelliteModelLoader.showSatellite(noradId, scene);

        if (newModel) {
            detailedSatelliteModel = newModel;
            const tleSat = satellites.find(s => s.norad_id.toString() === noradId.toString());

            if (tleSat) {
                currentSelectedSatellite = tleSat;
                tleSat.isSelected = true;
                if (tleSat.mesh) tleSat.mesh.visible = false;

                satellites.forEach(s => {
                    if (s !== tleSat && s.mesh) {
                        s.isSelected = false;
                        s.mesh.material.color.set(0xffffff);
                        s.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
                    }
                });
            } else {
                currentSelectedSatellite = null;
            }

            updateSatelliteInfoPanel(detailedSatelliteModel.userData.sourceData, tleSat);
            positionCameraForSatellite(detailedSatelliteModel);
            if (simParams.showOrbit && currentSelectedSatellite) {
                updateOrbitTrajectory(currentSelectedSatellite);
            }

        } else {
            console.error("Failed to load detailed satellite model for NORAD ID:", noradId);
            const expectedPathMsg = `Expected at: ${(window.SATELLITE_MODELS_BASE_URL || (usingLocalAssets ? "json/satellites/" : "[Remote Path Error]")) + `${noradId}.json`}`;
            alert(`Failed to load 3D model for satellite NORAD ID: ${noradId}.\n\nPlease check the console for errors and ensure the file exists.\n${expectedPathMsg}`);

            if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
            simParams.selectedSatellite = "None";
            currentSelectedSatellite = null;
            resetCameraToDefault();
            updateSatelliteInfoPanel(null, null);
        }
    }

    function clearDetailedSatelliteView() {
        if (detailedSatelliteModel) {
            const oldNoradId = detailedSatelliteModel.userData.noradId;
            window.satelliteModelLoader.clearCurrentDetailedSat(scene);
            detailedSatelliteModel = null;

            if (oldNoradId) {
                const tleSat = satellites.find(s => s.norad_id.toString() === oldNoradId.toString());
                if (tleSat && tleSat.mesh) {
                    tleSat.mesh.visible = true;
                }
            }
        }
    }


    function positionCameraForSatellite(satelliteModel) {
        if (!satelliteModel || !camera || !controls) return;

        const earthCenter = new THREE_Module.Vector3(0, 0, 0);
        const satellitePosition = new THREE_Module.Vector3();
        satelliteModel.getWorldPosition(satellitePosition);

        const direction = new THREE_Module.Vector3().subVectors(satellitePosition, earthCenter).normalize();

        const boundingBox = new THREE_Module.Box3().setFromObject(satelliteModel);
        const satelliteSizeVec = new THREE_Module.Vector3();
        boundingBox.getSize(satelliteSizeVec);
        const diameter = Math.max(satelliteSizeVec.x, satelliteSizeVec.y, satelliteSizeVec.z, 0.5 * METERS_TO_SCENE_UNITS);

        const minViewDistance = diameter * 2;
        const distanceMultiplier = 4.0;
        let cameraOffsetDistance = Math.max(diameter * distanceMultiplier, minViewDistance);

        const distToSat = satellitePosition.length();
        if (cameraOffsetDistance > distToSat - EARTH_SCENE_RADIUS * 0.8) {
            cameraOffsetDistance = Math.max(minViewDistance, distToSat - EARTH_SCENE_RADIUS * 0.8);
        }

        const newCameraPosition = new THREE_Module.Vector3().addVectors(satellitePosition, direction.clone().multiplyScalar(cameraOffsetDistance));

        camera.position.copy(newCameraPosition);
        camera.lookAt(satellitePosition);
        controls.target.copy(satellitePosition);
        controls.update();
    }

    function resetCameraToDefault() {
        if (camera && controls && sceneConfig && sceneConfig.camera && sceneConfig.camera.position) {
            camera.position.set(...sceneConfig.camera.position);
            controls.target.set(0, 0, 0);
            controls.update();
        } else {
            console.warn("Cannot reset camera: camera, controls, or sceneConfig not fully initialized.");
        }
    }

    function updateSatelliteInfoPanel(modelSourceData, tleData) {
        if (!satelliteInfoDiv) return;
        let info = "";
        if (modelSourceData && modelSourceData.name) {
            info = `<div style="font-weight:bold; margin-bottom:3px; color: #00aaff;">Model: ${modelSourceData.name}</div>`;
            if (modelSourceData.operator) info += `<div>Operator: ${modelSourceData.operator}</div>`;
            if (modelSourceData.purpose) info += `<div>Purpose: ${modelSourceData.purpose}</div>`;
            if (tleData) {
                info += `<div>NORAD ID: ${tleData.norad_id}</div>`;
                info += `<div>Orbit Type: ${tleData.orbitType}</div>`;
                info += `<div style="color:#aaa; margin-top:5px; font-size:10px;">TLE1: ${tleData.tle_line1}</div>`;
                info += `<div style="color:#aaa; font-size:10px;">TLE2: ${tleData.tle_line2}</div>`;
            }
        } else if (tleData) {
            info = `<div style="font-weight:bold; margin-bottom:3px; color: #00aaff;">Selected: ${tleData.satellite_name}</div>
                    <div>Company: ${tleData.company}</div><div>Type: ${tleData.orbitType}</div>
                    <div>Launch: ${tleData.launch_date || "N/A"}</div><div>NORAD: ${tleData.norad_id}</div>
                    <div style="color:#aaa; margin-top:5px; font-size:10px;">TLE1: ${tleData.tle_line1}</div>
                    <div style="color:#aaa; font-size:10px;">TLE2: ${tleData.tle_line2}</div>`;
        } else {
            info = `<div style="font-weight:bold;">No satellite selected</div>`;
        }
        satelliteInfoDiv.innerHTML = info;
    }

    function removeAllGeometry() {
        if (orbitLine) {
            scene.remove(orbitLine);
            orbitLine.geometry.dispose();
            orbitLine.material.dispose();
            orbitLine = null;
        }
    }

    function updateOrbitTrajectory(satData) {
        removeAllGeometry();
        if (!simParams.showOrbit || !satData || !satData.satrec) return;
        const meanMotion = satData.satrec.no;             // radians per minute
        if (meanMotion === 0) {
            console.warn(`${satData.satellite_name} has zero mean motion.`);
            return;
        }
        const periodMins = (2 * Math.PI) / meanMotion;
        const segments = 14400;
        const step = periodMins / segments;
        const orbitPoints = [];
        const now = new Date();
        for (let i = 0; i <= segments; i++) {
            const future = new Date(now.getTime() + i * step * 60000);
            const posVel = satellite.propagate(satData.satrec, future);
            if (!posVel || !posVel.position) continue;
            const {x, y, z} = posVel.position;
            const kmToScene = EARTH_SCENE_RADIUS / EARTH_RADIUS_KM;
            orbitPoints.push(new THREE_Module.Vector3(x * kmToScene, z * kmToScene, y * kmToScene));
        }
        if (orbitPoints.length < 2) {
            console.warn(`Not enough points for orbit: ${orbitPoints.length}`);
            return;
        }
        const geometry = new THREE_Module.BufferGeometry().setFromPoints(orbitPoints);
        const material = new THREE_Module.LineBasicMaterial({color: 0xff0000});
        orbitLine = new THREE_Module.Line(geometry, material);
        scene.add(orbitLine);
    }

    function projectToScreenCoordinates(worldVector, camera, renderer) {
        const vector = worldVector.clone();
        vector.project(camera);

        const x = (vector.x * .5 + .5) * renderer.domElement.clientWidth;
        const y = (vector.y * -.5 + .5) * renderer.domElement.clientHeight;

        return {x: x, y: y};
    }

    function update3DLabelsPosition() {
        if (!simParams.showECEFAxes || !camera || !renderer) {
            if (labelXecrDiv) labelXecrDiv.style.display = 'none';
            if (labelYecrDiv) labelYecrDiv.style.display = 'none';
            if (labelZecrDiv) labelZecrDiv.style.display = 'none';
            if (labelNorthPoleDiv) labelNorthPoleDiv.style.display = 'none';
            if (labelEquatorLineDiv) labelEquatorLineDiv.style.display = 'none';
            if (labelGreenwichMeridianDiv) labelGreenwichMeridianDiv.style.display = 'none';
            return;
        }

        const TARGET_AXIS_LENGTH_KM = 400;
        const visualAxisExtentInSceneUnits = TARGET_AXIS_LENGTH_KM * KM_TO_SCENE_UNITS;
        const labelOffset = 0.3;
        const labelVerticalOffset = 0.3;

        if (ecefXAxisHelper && labelXecrDiv) {
            const endOfXAxis = new THREE_Module.Vector3(visualAxisExtentInSceneUnits + labelOffset, 0, 0);
            const posX = projectToScreenCoordinates(endOfXAxis, camera, renderer);
            labelXecrDiv.style.left = `${posX.x}px`;
            labelXecrDiv.style.top = `${posX.y}px`;
            labelXecrDiv.style.display = 'block';
        }
        if (ecefYAxisHelper && labelYecrDiv) {
            const endOfYAxis = new THREE_Module.Vector3(0, 0, visualAxisExtentInSceneUnits + labelOffset);
            const posY = projectToScreenCoordinates(endOfYAxis, camera, renderer);
            labelYecrDiv.style.left = `${posY.x}px`;
            labelYecrDiv.style.top = `${posY.y}px`;
            labelYecrDiv.style.display = 'block';
        }
        if (ecefZAxisHelper && labelZecrDiv) {
            const endOfZAxis = new THREE_Module.Vector3(0, visualAxisExtentInSceneUnits + labelOffset, 0);
            const posZ = projectToScreenCoordinates(endOfZAxis, camera, renderer);
            labelZecrDiv.style.left = `${posZ.x}px`;
            labelZecrDiv.style.top = `${posZ.y}px`;
            labelZecrDiv.style.display = 'block';
        }
        if (labelNorthPoleDiv) {
            const northPolePos = projectToScreenCoordinates(new THREE_Module.Vector3(0, EARTH_SCENE_RADIUS + 0.8, 0), camera, renderer);
            labelNorthPoleDiv.style.left = `${northPolePos.x}px`;
            labelNorthPoleDiv.style.top = `${northPolePos.y}px`;
            labelNorthPoleDiv.style.display = 'block';
        }

        if (equatorLineMesh && labelEquatorLineDiv && equatorLineMesh.userData.radius) {
            const cameraPosition = new THREE_Module.Vector3();
            camera.getWorldPosition(cameraPosition);

            const cameraPosOnEquatorPlane = new THREE_Module.Vector3(cameraPosition.x, 0, cameraPosition.z);
            if (cameraPosOnEquatorPlane.lengthSq() < 0.001) {
                cameraPosOnEquatorPlane.set(equatorLineMesh.userData.radius, 0, 0);
            } else {
                cameraPosOnEquatorPlane.normalize().multiplyScalar(equatorLineMesh.userData.radius);
            }
            const equatorLabelPos3D = new THREE_Module.Vector3(cameraPosOnEquatorPlane.x, labelVerticalOffset, cameraPosOnEquatorPlane.z);

            const equatorScreenPos = projectToScreenCoordinates(equatorLabelPos3D, camera, renderer);
            labelEquatorLineDiv.style.left = `${equatorScreenPos.x}px`;
            labelEquatorLineDiv.style.top = `${equatorScreenPos.y}px`;
            labelEquatorLineDiv.style.display = 'block';
        }

        if (greenwichMeridianLineMesh && labelGreenwichMeridianDiv && equatorLineMesh.userData.radius) {
            const r = equatorLineMesh.userData.radius;
            const angleFromPole = Math.PI / 3;
            const meridianLabelPos3D = new THREE_Module.Vector3(
                r * Math.sin(angleFromPole),
                r * Math.cos(angleFromPole) + labelVerticalOffset,
                0.3
            );
            const meridianScreenPos = projectToScreenCoordinates(meridianLabelPos3D, camera, renderer);
            labelGreenwichMeridianDiv.style.left = `${meridianScreenPos.x}px`;
            labelGreenwichMeridianDiv.style.top = `${meridianScreenPos.y}px`;
            labelGreenwichMeridianDiv.style.display = 'block';
        }
    }


    function animate() {
        requestAnimationFrame(animate);
        const now = new Date();
        const jdayNow = satellite.jday(now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
        const gmstNow = satellite.gstime(jdayNow);

        satellites.forEach(sat => {
            if (!sat.mesh || !sat.mesh.visible || !sat.satrec) return;
            try {
                const posVel = satellite.propagate(sat.satrec, now);
                if (!posVel || !posVel.position) return;
                const ecf = satellite.eciToEcf(posVel.position, gmstNow);
                const kmToScene = EARTH_SCENE_RADIUS / EARTH_RADIUS_KM;
                sat.mesh.position.set(ecf.x * kmToScene, ecf.z * kmToScene, ecf.y * kmToScene);

                if (detailedSatelliteModel && detailedSatelliteModel.userData.noradId && detailedSatelliteModel.userData.noradId.toString() === sat.norad_id.toString()) {
                    detailedSatelliteModel.position.copy(sat.mesh.position);
                }

            } catch (e) { /* Silent error */
            }
        });

        const show3D = simParams.view3D;
        const showMercator = simParams.viewMercator;

        if (renderer) renderer.domElement.style.display = (show3D) ? "block" : "none";
        if (labelRenderer) labelRenderer.domElement.style.display = (show3D) ? "block" : "none";

        if (mercatorContainer) {
            if (showMercator) {
                mercatorContainer.style.display = "block";
                if (!show3D) {
                    mercatorContainer.classList.add("fullscreen");
                } else {
                    mercatorContainer.classList.remove("fullscreen");
                }
                if (mercatorCanvasElement && mapBackgroundDiv) {
                    const currentMapContainerWidth = mapBackgroundDiv.clientWidth;
                    const currentMapContainerHeight = mapBackgroundDiv.clientHeight;
                    if (mercatorCanvasElement.width !== currentMapContainerWidth || mercatorCanvasElement.height !== currentMapContainerHeight) {
                        mercatorCanvasElement.width = currentMapContainerWidth;
                        mercatorCanvasElement.height = currentMapContainerHeight;
                    }
                    updateMercatorMap();
                }
            } else {
                mercatorContainer.style.display = "none";
            }
        }

        if (show3D) {
            if (controls) controls.update();
            if (renderer && scene && camera) renderer.render(scene, camera);
            if (labelRenderer && scene && camera) labelRenderer.render(scene, camera);
            update3DLabelsPosition();
        } else {
            if (labelXecrDiv) labelXecrDiv.style.display = 'none';
            if (labelYecrDiv) labelYecrDiv.style.display = 'none';
            if (labelZecrDiv) labelZecrDiv.style.display = 'none';
            if (labelNorthPoleDiv) labelNorthPoleDiv.style.display = 'none';
            if (labelEquatorLineDiv) labelEquatorLineDiv.style.display = 'none';
            if (labelGreenwichMeridianDiv) labelGreenwichMeridianDiv.style.display = 'none';
        }
    }

    function drawDayNightTerminatorMercator(ctx, width, height) {
        const now = new Date();
        const hoursUTC = now.getUTCHours() + now.getUTCMinutes() / 60;
        const subSolarLon = (hoursUTC * 15) - 180;
        const dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
        const N = dayOfYear;
        const declRad = -Math.asin(0.39779 * Math.cos(0.98565 * (N + 10) * Math.PI / 180 + 1.914 * Math.sin(0.98565 * (N - 2) * Math.PI / 180) * Math.PI / 180));
        const subSolarLat = declRad * 180 / Math.PI;

        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.35)";
        ctx.beginPath();

        const points = [];
        let firstPoint = null, lastPoint = null;

        for (let i = 0; i <= width; i++) {
            const lon = (i / width) * 360 - 180;
            let terminatorLat = Math.atan(-Math.cos((lon - subSolarLon) * Math.PI / 180) / Math.tan(subSolarLat * Math.PI / 180)) * 180 / Math.PI;
            terminatorLat = Math.max(-85.05112878, Math.min(85.05112878, terminatorLat));
            const p = latLonToMercator(terminatorLat, lon);
            points.push(p);
            if (i === 0) firstPoint = p;
            if (i === width) lastPoint = p;
        }

        if (!firstPoint) {
            ctx.restore();
            return;
        }

        ctx.moveTo(firstPoint.x, firstPoint.y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }

        if (subSolarLat > 0) {
            ctx.lineTo(lastPoint.x, height);
            ctx.lineTo(firstPoint.x, height);
        } else {
            ctx.lineTo(lastPoint.x, 0);
            ctx.lineTo(firstPoint.x, 0);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    function updateMercatorMap() {
        if (!mercatorCtx || !mercatorCanvasElement || mercatorContainer.style.display === 'none') return;

        mercatorCtx.clearRect(0, 0, mercatorCanvasElement.width, mercatorCanvasElement.height);

        if (typeof drawDayNightTerminatorMercator === 'function') {
            drawDayNightTerminatorMercator(mercatorCtx, mercatorCanvasElement.width, mercatorCanvasElement.height);
        }

        const now = new Date();
        const jdayNow = satellite.jday(now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
        const gmstNow = satellite.gstime(jdayNow);
        let labelPositions = [];

        const satDrawData = satellites
            .filter(sat => sat.mesh && sat.mesh.visible && sat.satrec)
            .map(sat => {
                try {
                    const posVel = satellite.propagate(sat.satrec, now);
                    if (!posVel || !posVel.position) return null;
                    const geo = satellite.eciToGeodetic(posVel.position, gmstNow);
                    const pt = latLonToMercator(satellite.degreesLat(geo.latitude), satellite.degreesLong(geo.longitude));
                    return {sat, pt, name: sat.satellite_name};
                } catch (e) {
                    return null;
                }
            })
            .filter(Boolean)
            .sort((a, b) => a.pt.y - b.pt.y);

        satDrawData.forEach(data => {
            const {sat, pt, name} = data;
            const iconSize = 12;
            const leaderLength = 15;
            const textPadding = {x: 5, y: 3};

            if (mercatorSatIconLoaded && mercatorSatIcon.complete && mercatorSatIcon.naturalHeight !== 0) {
                mercatorCtx.drawImage(mercatorSatIcon, pt.x - iconSize / 2, pt.y - iconSize / 2, iconSize, iconSize);
            } else {
                mercatorCtx.beginPath();
                mercatorCtx.arc(pt.x, pt.y, iconSize / 2, 0, 2 * Math.PI);
                mercatorCtx.fillStyle = sat.isSelected ? "rgba(255,0,0,0.8)" : "rgba(0,255,0,0.8)";
                mercatorCtx.fill();
            }

            mercatorCtx.font = sat.isSelected ? "bold 11px Arial" : "10px Arial";
            const textMetrics = mercatorCtx.measureText(name);
            const labelWidth = textMetrics.width + 2 * textPadding.x;
            const labelHeight = 12 + 2 * textPadding.y;

            const angles = [-Math.PI / 4, -Math.PI / 2, -3 * Math.PI / 4, Math.PI, 3 * Math.PI / 4, Math.PI / 2, Math.PI / 4, 0];
            let bestPos = null;

            for (const angle of angles) {
                const leaderEndX = pt.x + (iconSize / 2 + leaderLength) * Math.cos(angle);
                const leaderEndY = pt.y + (iconSize / 2 + leaderLength) * Math.sin(angle);
                let textX = leaderEndX + ((Math.cos(angle) >= 0 || Math.abs(Math.cos(angle)) < 0.1) ? textPadding.x : -labelWidth + textPadding.x);
                let textY = leaderEndY - labelHeight / 2;
                const currentLabelRect = {
                    x: textX - textPadding.x,
                    y: textY - textPadding.y,
                    width: labelWidth,
                    height: labelHeight
                };

                let isOverlapping = labelPositions.some(lp =>
                    currentLabelRect.x < lp.x + lp.width && currentLabelRect.x + currentLabelRect.width > lp.x &&
                    currentLabelRect.y < lp.y + lp.height && currentLabelRect.y + currentLabelRect.height > lp.y);

                if (!isOverlapping) {
                    bestPos = {leaderEndX, leaderEndY, textX, textY, labelRect: currentLabelRect};
                    break;
                }
            }

            if (bestPos) {
                labelPositions.push(bestPos.labelRect);
                mercatorCtx.beginPath();
                mercatorCtx.moveTo(pt.x, pt.y);
                mercatorCtx.lineTo(bestPos.leaderEndX, bestPos.leaderEndY);
                mercatorCtx.strokeStyle = "rgba(200, 200, 200, 0.7)";
                mercatorCtx.lineWidth = 1;
                mercatorCtx.stroke();
                mercatorCtx.fillStyle = "rgba(0, 0, 0, 0.6)";
                mercatorCtx.fillRect(bestPos.labelRect.x, bestPos.labelRect.y, bestPos.labelRect.width, bestPos.labelRect.height);
                mercatorCtx.fillStyle = sat.isSelected ? "#ff8080" : "#00ddff";
                mercatorCtx.textAlign = "left";
                mercatorCtx.textBaseline = "middle";
                mercatorCtx.fillText(name, bestPos.textX, bestPos.textY + labelHeight / 2 - textPadding.y / 2 + 1);
            } else {
                mercatorCtx.fillStyle = sat.isSelected ? "#ff4444" : "#00aaff";
                mercatorCtx.textAlign = "center";
                mercatorCtx.textBaseline = "bottom";
                mercatorCtx.fillText(name, pt.x, pt.y - iconSize / 2 - 2);
            }
        });
    }

    function latLonToMercator(latDeg, lonDeg) {
        const currentWidth = mercatorCanvasElement ? mercatorCanvasElement.width : mapWidth;
        const currentHeight = mercatorCanvasElement ? mercatorCanvasElement.height : mapHeight;
        const x = (lonDeg + 180) * (currentWidth / 360);
        const clampedLatDeg = Math.max(-85.05112878, Math.min(85.05112878, latDeg));
        const latRad = clampedLatDeg * Math.PI / 180;
        const mercN = Math.log(Math.tan((Math.PI / 4) + (latRad / 2)));
        const y = (currentHeight / 2) - (currentWidth * mercN / (2 * Math.PI));
        return {x, y};
    }

    function onWindowResize() {
        if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (labelRenderer) labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    window.addEventListener('resize', onWindowResize);

    async function start() {
        try {
            await loadConfigs();
            init3D();
            initMercatorView();
            await setupTLESatellites();

            setupHTMLControls();
            updateSatelliteList();
            updateECEFAxesVisibility();

            if (simParams.showOrbit && currentSelectedSatellite) {
                updateOrbitTrajectory(currentSelectedSatellite);
            } else {
                simParams.showOrbit = false;
                if (showOrbitToggle) showOrbitToggle.checked = false;
            }
            animate();
        } catch (e) {
            console.error("Critical error during initialization:", e);
            document.body.innerHTML = `<div style="color:red; padding:20px; font-family:monospace;"><h1>Initialization Failed</h1><pre>${e.stack || e.message}</pre><p>Check console and ensure remote resources (configs, TLEs, textures) are accessible on GitHub and paths are correct.</p></div>`;
        }
    }

    start();
</script>
</body>
</html>