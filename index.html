<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Satellite Simulation - HTML Controls</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <script src="https://unpkg.com/satellite.js@4.0.0/dist/satellite.min.js"></script>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
          }
        }
    </script>
</head>
<body>
<button id="menuToggleBtn">✕</button>
<div id="ob_menu"></div>
<div id="mercatorContainer">
    <div class="mapBackground">
        <canvas id="mercatorCanvas"></canvas>
    </div>
</div>
<div id="utcClockDisplay"></div>

<script type="module">
    let usingLocalAssets;
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    import {
        mercatorCanvasElement,
        mapBackgroundDiv,
        mercatorContainer,
        mapHeight,
        mapWidth,
        mercatorCtx,
        initMercatorView,
        updateMercatorMap
    } from './js/mercatorMapLoader.js';

    import { drawDayNight3D } from './js/drawDayNight.js';

    import {
        SATELLITES_BASE_URL,
        satelliteConfig,
        earthConfig,
        sceneConfig,
        controlsConfig,
        checkFileExists
    } from './js/SatelliteConfigurationLoader.js';

    import { updateSatelliteInfo, satelliteMenuLoader } from './js/SatelliteMenuLoader.js';

    import {
        showSatellite,
        clearCurrentDetailedSat,
        updateBusOrientation
    } from './js/satelliteModelLoader.js';

    import { addECEFAxes, update3DLabelsPosition, updateECEFAxesVisibility } from './js/EarthFrameLoader.js';

    import {
        createOrbitFrame,
        updateOrbitFrame,
        setOrbitFrameVisibility,
        disposeOrbitFrame
    } from './js/orbitFrameLoader.js';

    import { KM_TO_SCENE_UNITS, EARTH_SCENE_RADIUS } from './js/SatelliteConstantLoader.js';
    import { satellites, updateOrbitTrajectory, setupTLESatellites, removeAllGeometry } from './js/satelliteTLELoader.js';

    import { createYPRFrame, updateYPRFrame, setYPRVisibility } from './js/satelliteYawPitchRollLoader.js';

    import { initFootprintRenderer, updateFootprints } from './js/satelliteFootprintLoader.js';

    import { createMoon, updateMoon } from './js/MoonFrameLoader.js';

    import { initTimeline } from './js/ganttTimelineLoader.js';

    // UI
    const versionNumber = "1.0o";
    const versionRepoUrl = "https://github.com/arcazj/openbexi_earth_orbit";
    const versionText = `version ${versionNumber} - hosted at`;
    document.getElementById('ob_menu').innerHTML = satelliteMenuLoader();

    // ─────────────────────────────────────────────────────────────
    // Perf constants and reusable scratch objects
    // ─────────────────────────────────────────────────────────────
    const V_TMP1 = new THREE.Vector3();
    const V_TMP2 = new THREE.Vector3();
    const V_TMP3 = new THREE.Vector3();
    const AXIS_Y = new THREE.Vector3(0, 1, 0);

    // Simulation time (reuse Date to avoid GC)
    let simMillis = Date.now();
    const SIM_DATE = new Date();

    // Throttles
    let lastClockUpdate = 0;      // ms
    let lastMercatorRedraw = 0;   // ms

    // Helper: write ECEF→scene into "out"
    function ecefToScene(out, x, y, z, rotY) {
        // Swap Y↔Z for scene, rotate around Y, scale to scene units
        return out.set(x, z, y)
            .applyAxisAngle(AXIS_Y, rotY)
            .multiplyScalar(KM_TO_SCENE_UNITS);
    }

    let moon;
    let scene, camera, renderer, earthMesh, controls;
    let orbitFrame = null;
    let currentSelectedSatellite = null;
    let textureLoader;
    let detailedSatelliteModel = null;
    let yprFrame;

    const simParams = {
        orbitTypeFilter: "MEO",
        companyFilter: "ALL COMPANY",
        selectedSatelliteName: "None",
        showOrbit: false,
        view3D: true,
        viewMercator: false,
        useHighDefTexture: false,
        showECEFAxes: false,
        showOrbitFrame: false,
        yawDeg: 0,
        pitchDeg: 0,
        rollDeg: 0,
        showYPR: false,
        showDayNight: false,
        simDate: new Date(),
        timeWarp: 1,
        showFootprint: false,
        showOnlySelectedSatellite: false,
        otherSelection: 'Earth'
    };

    let orbitTypeFilterSelect, companyFilterSelect, satelliteCountDisplay;
    let view3DToggle, viewMercatorToggle, showOrbitToggle, showOrbitFrameToggle;
    let highDefToggleElement, showECEFAxesToggleElement, showOrbitFrameToggleElement;
    let satelliteSelectDropdown, satelliteInfoDiv;
    let controlsContainerElement, menuToggleBtnElement, versionDisplayElement;
    let labelXecrDiv, labelYecrDiv, labelZecrDiv, labelNorthPoleDiv, labelEquatorLineDiv, labelGreenwichMeridianDiv;

    // Time-warp UI
    simParams.timeWarp = 1 / 60;
    simParams.simDate = new Date();
    simMillis = simParams.simDate.getTime();

    const twHTML = `
  <div id="timeWarpBox"
       style="position:fixed;top:5px;left:50%;transform:translateX(-50%);
              font:12px/1 sans-serif;z-index:3000;">
    <label for="timeWarpSlider">Time&nbsp;×</label>
    <input type="range" id="timeWarpSlider" min="0" max="60" step="1" value="0" style="width:200px;">
    <span id="timeWarpVal">0</span>x
  </div>`;
    document.body.insertAdjacentHTML('beforeend', twHTML);
    const timeWarpSlider = document.getElementById('timeWarpSlider');
    const timeWarpVal = document.getElementById('timeWarpVal');

    function updateEarthTexture() {
        if (!earthMesh || !textureLoader || !earthConfig) return;

        const textureToLoad = simParams.useHighDefTexture ? earthConfig.texture : earthConfig.textureLight;
        if (!textureToLoad) {
            earthMesh.material.map = null;
            earthMesh.material.color.set(0x1a237e);
            earthMesh.material.needsUpdate = true;
            return;
        }

        textureLoader.load(
            textureToLoad,
            (texture) => {
                // Reasonable defaults for globe (keep mipmaps for quality)
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 1;
                earthMesh.material.map = texture;
                earthMesh.material.color.set(0xffffff);
                earthMesh.material.needsUpdate = true;
            },
            undefined,
            () => {
                const placeholderUrl = `https://placehold.co/${simParams.useHighDefTexture ? '4096x2048' : '1024x512'}/1c313a/ffffff?text=Earth+Texture+Load+Error`;
                textureLoader.load(placeholderUrl, (fallbackMap) => {
                    earthMesh.material.map = fallbackMap;
                    earthMesh.material.needsUpdate = true;
                });
            }
        );
    }

    function init3D() {
        /* Scene, Camera, Renderer */
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
            sceneConfig.camera.fov,
            window.innerWidth / window.innerHeight,
            sceneConfig.camera.near,
            sceneConfig.camera.far
        );
        camera.position.set(...sceneConfig.camera.position);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Keep global shadows on; Sun light in drawDayNight3D has shadows disabled by default
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // expose
        window.renderer = renderer;
        window.camera = camera;

        /* Lighting */
        scene.add(new THREE.AmbientLight(0xffffff, 0.15));

        const dirLight = new THREE.DirectionalLight(
            sceneConfig.directionalLight.color,
            sceneConfig.directionalLight.intensity
        );
        dirLight.position.set(...sceneConfig.directionalLight.position);
        // Keep shadows off on helper light to save perf
        dirLight.castShadow = false;
        scene.add(dirLight);

        /* Earth */
        textureLoader = new THREE.TextureLoader();
        const earthMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
        earthMesh = new THREE.Mesh(
            new THREE.SphereGeometry(EARTH_SCENE_RADIUS, 64, 64),
            earthMat
        );
        earthMesh.receiveShadow = true;
        scene.add(earthMesh);
        updateEarthTexture();

        /* ECEF Axes */
        addECEFAxes(scene);
        updateECEFAxesVisibility(simParams);

        /* LVLH */
        orbitFrame = createOrbitFrame(scene);
        setOrbitFrameVisibility(orbitFrame, false);

        /* Moon (always visible) */
        moon = createMoon(scene, EARTH_SCENE_RADIUS, {
            textureUrl: 'textures/moon_map2.jpg'
        });

        /* Controls */
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = controlsConfig.enableDamping;
        controls.dampingFactor = controlsConfig.dampingFactor;
        controls.minDistance = EARTH_SCENE_RADIUS * 1.4;
        controls.maxDistance = EARTH_SCENE_RADIUS * 20;
        controls.enableZoom = true;
    }

    function setupHTMLControls() {
        controlsContainerElement = document.getElementById('controlsContainer');
        menuToggleBtnElement = document.getElementById('menuToggleBtn');
        versionDisplayElement = document.getElementById('versionDisplay');

        if (versionDisplayElement) {
            const versionLink = document.createElement('a');
            versionLink.href = versionRepoUrl;
            versionLink.textContent = `GitHub Repo`;
            versionLink.target = "_blank";
            versionDisplayElement.textContent = `${versionText} `;
            versionDisplayElement.appendChild(versionLink);
        }

        orbitTypeFilterSelect = document.getElementById('orbitTypeFilter');
        companyFilterSelect = document.getElementById('companyFilter');
        satelliteCountDisplay = document.getElementById('satelliteCountDisplay');

        view3DToggle = document.getElementById('view3DToggle');
        viewMercatorToggle = document.getElementById('viewMercatorToggle');
        highDefToggleElement = document.getElementById('highDefToggle');
        showECEFAxesToggleElement = document.getElementById('showECEFAxesToggle');
        showOrbitFrameToggleElement = document.getElementById('showOrbitFrameToggle');
        showOrbitToggle = document.getElementById('showOrbitToggle');

        satelliteSelectDropdown = document.getElementById('satelliteSelect');
        satelliteInfoDiv = document.getElementById('satelliteInfo');

        // Labels
        labelXecrDiv = document.getElementById('labelXecr');
        labelYecrDiv = document.getElementById('labelYecr');
        labelZecrDiv = document.getElementById('labelZecr');
        labelNorthPoleDiv = document.getElementById('labelNorthPole');
        labelEquatorLineDiv = document.getElementById('labelEquatorLine');
        labelGreenwichMeridianDiv = document.getElementById('labelGreenwichMeridian');

        // YPR sliders
        const yprControls = document.getElementById('yprControls');
        const yawSlider = document.getElementById('yawSlider');
        const pitchSlider = document.getElementById('pitchSlider');
        const rollSlider = document.getElementById('rollSlider');
        const yawVal = document.getElementById('yawVal');
        const pitchVal = document.getElementById('pitchVal');
        const rollVal = document.getElementById('rollVal');

        orbitTypeFilterSelect.value = simParams.orbitTypeFilter;
        view3DToggle.checked = simParams.view3D;
        viewMercatorToggle.checked = simParams.viewMercator;
        if (highDefToggleElement) highDefToggleElement.checked = simParams.useHighDefTexture;
        if (showECEFAxesToggleElement) showECEFAxesToggleElement.checked = simParams.showECEFAxes;
        if (showOrbitFrameToggleElement) showOrbitFrameToggleElement.checked = simParams.showOrbitFrame;
        showOrbitToggle.checked = simParams.showOrbit;

        // Time-warp slider
        timeWarpSlider.addEventListener('input', e => {
            simParams.timeWarp = parseInt(e.target.value, 10);
            if (simParams.timeWarp < 1) {
                timeWarpVal.textContent = `0`;
                simParams.timeWarp = 1 / 60;
            } else {
                timeWarpVal.textContent = `${simParams.timeWarp}`;
            }
        });

        const showFootprintChk = document.getElementById('showFootprintCheckbox');
        showFootprintChk.addEventListener('change', () => {
            simParams.showFootprint = showFootprintChk.checked;
        });

        const showOnlySelectedSatelliteChk = document.getElementById('showOnlySelectedSatellite');
        if (showOnlySelectedSatelliteChk) {
            showOnlySelectedSatelliteChk.checked = !!simParams.showOnlySelectedSatellite;
            showOnlySelectedSatelliteChk.addEventListener('change', () => {
                simParams.showOnlySelectedSatellite = showOnlySelectedSatelliteChk.checked;
                updateSatelliteList();
            });
        }

        orbitTypeFilterSelect.addEventListener('change', (e) => {
            simParams.orbitTypeFilter = e.target.value;
            simParams.showOrbit = false;
            if (showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry(scene);
            updateSatelliteList();
        });

        companyFilterSelect.addEventListener('change', (e) => {
            simParams.companyFilter = e.target.value;
            simParams.showOrbit = false;
            if (showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry(scene);
            updateSatelliteList();
        });

        view3DToggle.addEventListener('change', (e) => simParams.view3D = e.target.checked);
        viewMercatorToggle.addEventListener('change', (e) => simParams.viewMercator = e.target.checked);

        if (highDefToggleElement) {
            highDefToggleElement.addEventListener('change', (e) => {
                simParams.useHighDefTexture = e.target.checked;
                updateEarthTexture();
            });
        }
        if (showECEFAxesToggleElement) {
            showECEFAxesToggleElement.addEventListener('change', (e) => {
                simParams.showECEFAxes = e.target.checked;
                updateECEFAxesVisibility(simParams);
            });
        }

        if (showOrbitFrameToggleElement) {
            showOrbitFrameToggleElement.addEventListener('change', e => {
                simParams.showOrbitFrame = e.target.checked;
                if (orbitFrame) setOrbitFrameVisibility(orbitFrame, simParams.showOrbitFrame);
            });
        }

        showOrbitToggle.addEventListener('change', (e) => {
            simParams.showOrbit = e.target.checked;
            if (currentSelectedSatellite && simParams.showOrbit) {
                updateOrbitTrajectory(scene, simParams, currentSelectedSatellite);
            } else {
                simParams.showOrbit = false;
                e.target.checked = false;
            }
        });

        satelliteSelectDropdown.addEventListener('change', handleSatelliteDropdownChange);

        const showYPRToggle = document.getElementById('showYPRToggle');
        showYPRToggle.addEventListener('change', e => {
            const v = e.target.checked;
            simParams.showYPR = v;
            setYPRVisibility(yprFrame, v);
        });

        function updateYPRLabels() {
            yawVal.textContent = simParams.yawDeg.toFixed(1);
            pitchVal.textContent = simParams.pitchDeg.toFixed(1);
            rollVal.textContent = simParams.rollDeg.toFixed(1);
        }

        [yawSlider, pitchSlider, rollSlider].forEach(sl => {
            sl.addEventListener('input', () => {
                simParams.yawDeg = parseFloat(yawSlider.value);
                simParams.pitchDeg = parseFloat(pitchSlider.value);
                simParams.rollDeg = parseFloat(rollSlider.value);
                updateYPRLabels();
                updateBusOrientation(detailedSatelliteModel, simParams.yawDeg, simParams.pitchDeg, simParams.rollDeg);
            });
        });
        updateYPRLabels();

        // Collapsible sections
        document.querySelectorAll('#controlsContainer h3[data-collapsible-target]').forEach(header => {
            const targetId = header.dataset.collapsibleTarget;
            const targetContent = document.getElementById(targetId);
            const icon = header.querySelector('.toggle-icon');

            if (targetContent && icon) {
                targetContent.classList.remove('collapsed');
                icon.classList.remove('collapsed');
                icon.textContent = '▾';
                header.addEventListener('click', () => {
                    targetContent.classList.toggle('collapsed');
                    icon.classList.toggle('collapsed');
                    icon.textContent = targetContent.classList.contains('collapsed') ? '▸' : '▾';
                });
            }
        });

        // Menu toggle button
        if (menuToggleBtnElement && controlsContainerElement) {
            menuToggleBtnElement.addEventListener('click', () => {
                controlsContainerElement.classList.toggle('menu-hidden');
                menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕';
            });
            menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕';
        }

        const showDayNightToggle = document.getElementById('showDayNightToggle');
        showDayNightToggle.checked = simParams.showDayNight;
        simParams.showDayNight = showDayNightToggle.checked;
        showDayNightToggle.addEventListener('change', e => {
            simParams.showDayNight = e.target.checked;
        });

        // Other Selections (Earth/Moon)
        const otherSelLabel = document.createElement('label');
        otherSelLabel.textContent = 'Other Selections';
        otherSelLabel.setAttribute('for', 'otherSelection');
        otherSelLabel.style.display = 'block';
        otherSelLabel.style.marginTop = '8px';

        const otherSel = document.createElement('select');
        otherSel.id = 'otherSelection';
        otherSel.style.width = '100%';
        ['Earth', 'Moon'].forEach(v => {
            const opt = document.createElement('option');
            opt.value = v;
            opt.textContent = v;
            otherSel.appendChild(opt);
        });
        otherSel.value = simParams.otherSelection;

        if (satelliteSelectDropdown && satelliteSelectDropdown.parentElement) {
            satelliteSelectDropdown.parentElement.appendChild(otherSelLabel);
            satelliteSelectDropdown.parentElement.appendChild(otherSel);
        } else if (controlsContainerElement) {
            controlsContainerElement.appendChild(otherSelLabel);
            controlsContainerElement.appendChild(otherSel);
        }

        otherSel.addEventListener('change', () => {
            simParams.otherSelection = otherSel.value;

            if (simParams.otherSelection === 'Moon') {
                if (satelliteSelectDropdown) {
                    satelliteSelectDropdown.value = 'None';
                    simParams.selectedSatelliteName = 'None';
                }
                selectSatelliteSprite(null);
                clearDetailedSatelliteView();
                removeAllGeometry(scene);

                // Fly to Moon and relax min distance
                flyCameraToSatellite(moon, 1500, false);
                const moonRadius = EARTH_SCENE_RADIUS * 0.27;
                controls.minDistance = Math.max(moonRadius * 1.1, 0.05 * EARTH_SCENE_RADIUS);
                controls.maxDistance = EARTH_SCENE_RADIUS * 8;

                controls.target.copy(moon.position);
                controls.update();
            } else {
                // The user said they call resetCameraToDefault(); keep that path.
                resetCameraToDefault();

                if (orbitTypeFilterSelect) {
                    orbitTypeFilterSelect.value = 'MEO';
                    simParams.orbitTypeFilter = 'MEO';
                }
                if (companyFilterSelect) {
                    companyFilterSelect.value = 'ALL COMPANY';
                    simParams.companyFilter = 'ALL COMPANY';
                }
                if (satelliteSelectDropdown) {
                    satelliteSelectDropdown.value = 'None';
                    simParams.selectedSatelliteName = 'None';
                }
                selectSatelliteSprite(null);
                clearDetailedSatelliteView();
                removeAllGeometry(scene);
                updateSatelliteList();
            }
        });
    }

    async function handleSatelliteDropdownChange(event) {
        const selectedNameInDropdown = event.target.value;
        simParams.selectedSatelliteName = selectedNameInDropdown;

        if (detailedSatelliteModel?.userData?.noradId) {
            const prevTleSat = satellites.find(s => s.norad_id.toString() === detailedSatelliteModel.userData.noradId.toString());
            if (prevTleSat?.mesh) {
                prevTleSat.mesh.visible = true;
                prevTleSat.isSelected = false;
                prevTleSat.mesh.material.color.set(0xffffff);
                prevTleSat.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
            }
        }

        clearDetailedSatelliteView();
        removeAllGeometry(scene);

        if (selectedNameInDropdown === "None") {
            currentSelectedSatellite = null;
            updateSatelliteInfo(satelliteInfoDiv, null);
            resetCameraToDefault();

            if (simParams.showOnlySelectedSatellite) {
                satellites.forEach(s => { if (s.mesh) s.mesh.visible = false; });
                if (satelliteCountDisplay) satelliteCountDisplay.textContent = '0';
            } else {
                updateSatelliteList();
            }
            return;
        }

        const tleSatData = satellites.find(s => s.satellite_name === selectedNameInDropdown);
        if (!tleSatData) {
            currentSelectedSatellite = null;
            updateSatelliteInfo(satelliteInfoDiv, null);
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
            simParams.selectedSatelliteName = "None";
            updateSatelliteList();
            return;
        }

        currentSelectedSatellite = tleSatData;
        updateSatelliteInfo(satelliteInfoDiv, tleSatData);

        if (simParams.showOnlySelectedSatellite) {
            satellites.forEach(s => { if (s.mesh) s.mesh.visible = (s === tleSatData); });
        }

        if (simParams.showOrbit) {
            updateOrbitTrajectory(scene, simParams, tleSatData);
        }

        let fileUrl = (usingLocalAssets ? "json/satellites/" : SATELLITES_BASE_URL) + `${tleSatData.norad_id}.json`;
        let fileExists = await checkFileExists(fileUrl);

        let updatedNoradId = tleSatData.norad_id;
        if (!fileExists && usingLocalAssets) {
            console.warn(`Local model file ${fileUrl} not found.`);
        } else if (!fileExists && !usingLocalAssets) {
            console.warn(`GitHub model file ${fileUrl} not found, attempting local fallback.`);
            fileUrl = "json/satellites/" + `${tleSatData.norad_id}.json`;
            fileExists = await checkFileExists(fileUrl);
            if (!fileExists) {
                const nameLower = selectedNameInDropdown.toLowerCase();
                if (nameLower.includes('3b'))       { updatedNoradId = "O3b";        fileExists = true; }
                if (nameLower.includes('oneweb'))   { updatedNoradId = "oneweb";     fileExists = true; }
                if (nameLower.includes('starlink')) { updatedNoradId = "starlink_V1"; fileExists = true; }
            }
        }

        if (fileExists) {
            await loadAndDisplayDetailedSatellite(tleSatData.norad_id, tleSatData, updatedNoradId);
            if (simParams.showOnlySelectedSatellite) updateSatelliteList();
        } else {
            selectSatelliteSprite(tleSatData);
            if (tleSatData.mesh) flyCameraToSatellite(tleSatData.mesh, 1000, true);
            updateSatelliteList();
        }

        const yprControls = document.getElementById('yprControls');
        if (yprControls) yprControls.style.display = 'block';
    }

    async function loadAndDisplayDetailedSatellite(noradId, tleSatData, updatedNoradId) {
        console.log(`Attempting to load detailed model for NORAD ID: ${noradId}`);
        const newModel = await showSatellite(noradId, scene, updatedNoradId);

        if (newModel) {
            detailedSatelliteModel = newModel;
            detailedSatelliteModel.userData.noradId = noradId;

            if (tleSatData?.satrec) {
                currentSelectedSatellite = tleSatData;
                tleSatData.isSelected = true;
                if (tleSatData.mesh) {
                    tleSatData.mesh.visible = true;
                }

                // Initial model position
                const now = SIM_DATE; // reuse
                const jdayNow = satellite.jday(
                    now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(),
                    now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds()
                );
                const gmstNow = satellite.gstime(jdayNow);
                const pv = satellite.propagate(tleSatData.satrec, now);
                if (pv?.position) {
                    const ecf = satellite.eciToEcf(pv.position, gmstNow);
                    detailedSatelliteModel.position.set(ecf.x * KM_TO_SCENE_UNITS, ecf.z * KM_TO_SCENE_UNITS, ecf.y * KM_TO_SCENE_UNITS);
                }
            } else {
                currentSelectedSatellite = null;
            }

            satellites.forEach(s => {
                if (s !== tleSatData && s.mesh) {
                    s.isSelected = false;
                    s.mesh.material.color.set(0xffffff);
                    s.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
                }
            });

            if (tleSatData.mesh) flyCameraToSatellite(tleSatData.mesh, 3000, false);
            if (simParams.showOrbit && currentSelectedSatellite) {
                updateOrbitTrajectory(scene, simParams, currentSelectedSatellite);
            }
        } else {
            if (tleSatData) {
                selectSatelliteSprite(tleSatData);
                if (tleSatData.mesh) flyCameraToSatellite(tleSatData.mesh, 1000, true);
            } else {
                if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
                simParams.selectedSatelliteName = "None";
                currentSelectedSatellite = null;
                resetCameraToDefault();
            }
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = "position:fixed; top:10px; left:10px; padding:10px; background:orange; color:black; z-index:1000;";
            errorDiv.innerText = `Failed to load 3D model for satellite NORAD ID: ${noradId}. Displaying TLE marker.`;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }
    }

    function clearDetailedSatelliteView() {
        if (detailedSatelliteModel) {
            const oldNoradId = detailedSatelliteModel.userData ? detailedSatelliteModel.userData.noradId : null;
            clearCurrentDetailedSat(scene);
            scene.remove(detailedSatelliteModel);
            detailedSatelliteModel = null;

            if (oldNoradId) {
                const tleSat = satellites.find(s => s.norad_id.toString() === oldNoradId.toString());
                if (tleSat?.mesh) {
                    tleSat.mesh.visible = true;
                }
            }
        }
    }

    const clock = new THREE.Clock();
    let cameraMove = null;

    function flyCameraToSatellite(targetObject, millis = 1500, isSprite = false) {
        if (!targetObject || !camera || !controls) return;

        const earthCenter = V_TMP1.set(0, 0, 0);
        const targetPos = V_TMP2.setFromMatrixPosition(targetObject.matrixWorld);
        const dirToTarget = V_TMP3.subVectors(targetPos, earthCenter).normalize();

        let distance;
        if (isSprite) {
            distance = EARTH_SCENE_RADIUS * 0.5;
        } else {
            const bbox = new THREE.Box3().setFromObject(targetObject);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            const modelDiameter = Math.max(size.x, size.y, size.z, 0.5 * KM_TO_SCENE_UNITS * 1000);
            distance = Math.max(modelDiameter, EARTH_SCENE_RADIUS * 0.5);
        }

        const endCamPos = V_TMP3.copy(dirToTarget).multiplyScalar(distance).add(targetPos);
        const startCamPos = camera.position.clone();
        const startTarget = controls.target.clone();
        const endTarget = targetPos.clone();

        cameraMove = {
            startTime: clock.getElapsedTime(),
            duration: millis / 1000,
            startCamPos,
            endCamPos: endCamPos.clone(),
            startTarget,
            endTarget
        };

        controls.enabled = false;
        controls.reset();
        camera.position.set(...sceneConfig.camera.position);
        controls.target.set(0, 0, 0);
    }

    function resetCameraToDefault() {
        if (camera && controls && sceneConfig?.camera?.position) {
            cameraMove = null;
            const startCamPos = camera.position.clone();
            const endCamPos = new THREE.Vector3(...sceneConfig.camera.position);
            const startTarget = controls.target.clone();
            const endTarget = new THREE.Vector3(0, 0, 0);
            cameraMove = {
                startTime: clock.getElapsedTime(),
                duration: 1.0,
                startCamPos, endCamPos,
                startTarget, endTarget
            };
            controls.enabled = false;
        }
    }

    function updateSatelliteList() {
        if (!satellites || !satelliteSelectDropdown || !companyFilterSelect) {
            if (satelliteCountDisplay) satelliteCountDisplay.textContent = '0';
            if (satelliteSelectDropdown) satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
            if (companyFilterSelect) {
                const currentCompanyVal = companyFilterSelect.value;
                companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
                if (currentCompanyVal !== "ALL COMPANY") {
                    const opt = document.createElement('option');
                    opt.value = currentCompanyVal;
                    opt.textContent = currentCompanyVal;
                    companyFilterSelect.appendChild(opt);
                    companyFilterSelect.value = currentCompanyVal;
                }
            }
            return;
        }

        const filteredTLEs = satellites.filter(s =>
            (simParams.orbitTypeFilter === "ALL" || s.orbitType === simParams.orbitTypeFilter) &&
            (simParams.companyFilter === "ALL COMPANY" || s.company === simParams.companyFilter)
        );

        satellites.forEach(s => {
            if (!s.mesh) return;

            const isVisibleInFilter =
                (simParams.orbitTypeFilter === "ALL" || s.orbitType === simParams.orbitTypeFilter) &&
                (simParams.companyFilter === "ALL COMPANY" || s.company === simParams.companyFilter);

            const isDetailedModelForThisSat =
                detailedSatelliteModel &&
                detailedSatelliteModel.userData &&
                detailedSatelliteModel.userData.noradId === s.norad_id.toString();

            let visible = isVisibleInFilter && !isDetailedModelForThisSat;

            if (simParams.showOnlySelectedSatellite) {
                if (!currentSelectedSatellite) {
                    visible = false;
                } else {
                    visible = (s === currentSelectedSatellite) && !isDetailedModelForThisSat;
                }
            }

            s.mesh.visible = visible;

            if (s.mesh.visible) {
                const isActuallySelected = currentSelectedSatellite === s;
                s.mesh.material.color.set(isActuallySelected ? 0xff0000 : 0xffffff);
                const baseScale = satelliteConfig.scale || [0.1, 0.1, 0.1];
                s.mesh.scale.set(...(isActuallySelected ? baseScale.map(v => v * 1.5) : baseScale));
            }
        });

        if (satelliteCountDisplay) {
            satelliteCountDisplay.textContent =
                simParams.showOnlySelectedSatellite ? (currentSelectedSatellite ? '1' : '0') : filteredTLEs.length.toString();
        }

        const uniqueCompanies = Array.from(new Set(satellites.map(s => s.company))).sort();
        const currentCompanySelection = companyFilterSelect.value;
        companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
        uniqueCompanies.forEach(comp => {
            if (comp && comp !== "N/A") {
                const option = document.createElement('option');
                option.value = comp;
                option.textContent = comp;
                companyFilterSelect.appendChild(option);
            }
        });
        if (uniqueCompanies.includes(currentCompanySelection)) {
            companyFilterSelect.value = currentCompanySelection;
        } else {
            companyFilterSelect.value = "ALL COMPANY";
        }

        const previousDropdownValue = satelliteSelectDropdown.value;
        satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
        filteredTLEs.forEach(s => {
            const option = document.createElement('option');
            option.value = s.satellite_name;
            option.textContent = s.satellite_name;
            satelliteSelectDropdown.appendChild(option);
        });

        if (filteredTLEs.some(s => s.satellite_name === previousDropdownValue)) {
            satelliteSelectDropdown.value = previousDropdownValue;
        } else {
            satelliteSelectDropdown.value = "None";
            if (currentSelectedSatellite && !filteredTLEs.includes(currentSelectedSatellite)) {
                if (!simParams.showOnlySelectedSatellite) {
                    clearDetailedSatelliteView();
                    currentSelectedSatellite = null;
                    updateSatelliteInfo(satelliteInfoDiv, null);
                }
            }
        }

        if (satelliteSelectDropdown.value === "None" && detailedSatelliteModel && !simParams.showOnlySelectedSatellite) {
            clearDetailedSatelliteView();
            currentSelectedSatellite = null;
            updateSatelliteInfo(satelliteInfoDiv, null);
        }
    }

    function selectSatelliteSprite(tleSatData) {
        satellites.forEach(s => {
            if (s.mesh && s.isSelected) {
                s.isSelected = false;
                if (s.mesh.visible) {
                    s.mesh.material.color.set(0xffffff);
                    s.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
                }
            }
        });

        currentSelectedSatellite = tleSatData;

        if (tleSatData?.mesh) {
            tleSatData.isSelected = true;
            if (tleSatData.mesh.visible) {
                tleSatData.mesh.material.color.set(0xff0000);
                tleSatData.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]).map(v => v * 1.5));
            }
            simParams.selectedSatelliteName = tleSatData.satellite_name;
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = tleSatData.satellite_name;
            updateOrbitTrajectory(scene, simParams, tleSatData);
        } else {
            simParams.selectedSatelliteName = "None";
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
            removeAllGeometry(scene);
        }
        updateSatelliteInfo(satelliteInfoDiv, tleSatData);
    }

    function handleTimelineSelection(tleSatData) {
        if (!tleSatData) return;
        if (orbitTypeFilterSelect) {
            orbitTypeFilterSelect.value = 'ALL';
            simParams.orbitTypeFilter = 'ALL';
        }
        if (companyFilterSelect) {
            companyFilterSelect.value = 'ALL COMPANY';
            simParams.companyFilter = 'ALL COMPANY';
        }
        simParams.showOnlySelectedSatellite = false;
        updateSatelliteList();
        if (satelliteSelectDropdown) {
            satelliteSelectDropdown.value = tleSatData.satellite_name;
            const changeEvent = new Event('change');
            satelliteSelectDropdown.dispatchEvent(changeEvent);
        }
    }

    window.addEventListener('keydown', e => {
        if (e.key === 'r') {
            controls.reset();
            camera.position.set(...sceneConfig.camera.position);
            controls.target.set(0, 0, 0);
        }
    });

    function formatUTCString(date) {
        const options = {
            weekday: 'short',
            year: 'numeric',
            month: 'long',
            day: '2-digit',
            timeZone: 'UTC',
        };
        const datePart = date.toLocaleDateString('en-US', options);
        const timePart = date.toUTCString().split(' ')[4]; // "HH:MM:SS"
        return `${timePart} UTC  ${datePart}`;
    }

    function animate() {
        requestAnimationFrame(animate);

        /* Camera easing */
        if (cameraMove) {
            const tReal = clock.getElapsedTime();
            const f = Math.min((tReal - cameraMove.startTime) / cameraMove.duration, 1);
            const s = f < 0.5 ? 2 * f * f : 1 - Math.pow(-2 * f + 2, 2) / 2;
            camera.position.lerpVectors(cameraMove.startCamPos, cameraMove.endCamPos, s);
            controls.target.lerpVectors(cameraMove.startTarget, cameraMove.endTarget, s);
            controls.update();
            if (f >= 1) { cameraMove = null; controls.enabled = true; }
        } else {
            controls.update();
        }

        /* Simulation clock: minutes * timeWarp per second */
        const dtReal = clock.getDelta();
        simMillis += dtReal * 1000 * 60 * simParams.timeWarp;
        SIM_DATE.setTime(simMillis);
        simParams.simDate = SIM_DATE; // keep external readers happy

        const jDay = satellite.jday(
            SIM_DATE.getUTCFullYear(), SIM_DATE.getUTCMonth() + 1, SIM_DATE.getUTCDate(),
            SIM_DATE.getUTCHours(), SIM_DATE.getUTCMinutes(), SIM_DATE.getUTCSeconds()
        );
        const gmstNow = satellite.gstime(jDay);
        const rotY = -gmstNow;

        // Update the UTC text ~2 Hz and the slider number immediately (cheap)
        const nowPerf = performance.now();
        if (nowPerf - lastClockUpdate > 500) {
            lastClockUpdate = nowPerf;
            const clockEl = document.getElementById("utcClockDisplay");
            if (clockEl) clockEl.textContent = formatUTCString(SIM_DATE);
        }
        if (timeWarpVal) {
            timeWarpVal.textContent = simParams.timeWarp < 1 ? '0' : `${simParams.timeWarp}`;
        }

        /* Earth rotation */
        if (earthMesh) earthMesh.rotation.y = rotY;

        /* Visible TLE sprites */
        for (const s of satellites) {
            if (!s.mesh || !s.mesh.visible || !s.satrec) continue;
            const pv = satellite.propagate(s.satrec, SIM_DATE);
            if (!pv || !pv.position) continue;
            const e = satellite.eciToEcf(pv.position, gmstNow);
            ecefToScene(s.mesh.position, e.x, e.y, e.z, rotY);
        }

        /* Detailed model (selected) */
        if (detailedSatelliteModel?.visible && currentSelectedSatellite?.satrec) {
            const pv = satellite.propagate(currentSelectedSatellite.satrec, SIM_DATE);
            if (pv?.position) {
                const e = satellite.eciToEcf(pv.position, gmstNow);
                ecefToScene(detailedSatelliteModel.position, e.x, e.y, e.z, rotY);
            }
        }

        /* LVLH orbit frame (selected) */
        if (simParams.showOrbitFrame && orbitFrame && currentSelectedSatellite?.satrec && currentSelectedSatellite.mesh?.visible) {
            const pv = satellite.propagate(currentSelectedSatellite.satrec, SIM_DATE);
            if (pv?.position && pv?.velocity) {
                const ep = satellite.eciToEcf(pv.position, gmstNow);
                const ev = satellite.eciToEcf(pv.velocity, gmstNow);
                updateOrbitFrame(
                    orbitFrame,
                    ecefToScene(V_TMP1, ep.x, ep.y, ep.z, rotY),
                    ecefToScene(V_TMP2, ev.x, ev.y, ev.z, rotY)
                );
            }
        }

        /* YPR frame */
        if (simParams.showYPR && yprFrame && currentSelectedSatellite?.mesh?.visible) {
            const pos = detailedSatelliteModel ? detailedSatelliteModel.position : currentSelectedSatellite.mesh.position;
            updateYPRFrame(yprFrame, pos, simParams.yawDeg, simParams.pitchDeg, simParams.rollDeg);
        }

        /* Earth/Moon controls target */
        if (!cameraMove && controls) {
            if (simParams.otherSelection === 'Moon' && moon) {
                // Unit vector Earth→Moon
                V_TMP1.copy(moon.position).normalize();
                const moonRadius = EARTH_SCENE_RADIUS * 0.27;
                const keepDist = Math.max(moonRadius * 4, EARTH_SCENE_RADIUS * 0.6);
                V_TMP2.copy(V_TMP1).multiplyScalar(keepDist).add(moon.position);

                // dt-aware smoothing keeps stable when Time× changes
                const chaseSmooth = 1 - Math.pow(0.001, dtReal); // fast, stable
                camera.position.lerp(V_TMP2, chaseSmooth);

                controls.target.copy(moon.position);
                controls.update();
            } else if (currentSelectedSatellite?.mesh?.visible) {
                const satPos = detailedSatelliteModel ? detailedSatelliteModel.position : currentSelectedSatellite.mesh.position;
                V_TMP1.copy(satPos).normalize();
                V_TMP2.copy(satPos).add(V_TMP1.multiplyScalar(EARTH_SCENE_RADIUS));
                // Optional: camera.position.copy(V_TMP2);
                controls.target.set(0, 0, 0);
                controls.update();
            }
        }

        /* Footprints */
        updateFootprints(currentSelectedSatellite, gmstNow, {
            showFootprint: !!simParams.showFootprint,
            mercatorCtx: null,
            simDate: SIM_DATE
        });

        /* Render 3-D vs Mercator */
        const show3D = simParams.view3D;
        if (renderer) renderer.domElement.style.display = show3D ? 'block' : 'none';
        if (show3D) {
            renderer.render(scene, camera);
            update3DLabelsPosition(camera, simParams);
        } else {
            ['labelXecr','labelYecr','labelZecr','labelNorthPole','labelEquatorLine','labelGreenwichMeridian']
                .forEach(id => { const el = document.getElementById(id); if (el) el.style.display = 'none'; });
        }

        if (mercatorContainer) {
            if (simParams.viewMercator) {
                mercatorContainer.style.display = 'block';
                mercatorContainer.classList.toggle('fullscreen', !show3D);
                if (mercatorCanvasElement && mapBackgroundDiv) {
                    const w = mapBackgroundDiv.clientWidth;
                    const h = mapBackgroundDiv.clientHeight;
                    if (mercatorCanvasElement.width !== w || mercatorCanvasElement.height !== h) {
                        mercatorCanvasElement.width = w;
                        mercatorCanvasElement.height = h;
                    }
                    // Throttle Mercator to ~30 FPS
                    if (performance.now() - lastMercatorRedraw > 33) {
                        lastMercatorRedraw = performance.now();
                        updateMercatorMap(simParams);
                        if (simParams.showFootprint) {
                            updateFootprints(currentSelectedSatellite, gmstNow, {
                                showFootprint: true, mercatorCtx, simDate: SIM_DATE
                            });
                        } else {
                            updateFootprints(currentSelectedSatellite, gmstNow, {
                                showFootprint: false, mercatorCtx, simDate: SIM_DATE
                            });
                        }
                    }
                }
            } else {
                mercatorContainer.style.display = 'none';
            }
        }

        /* Day / Night & Sun */
        if (simParams.showDayNight) {
            drawDayNight3D(scene, earthMesh, SIM_DATE, {
                showSun:  simParams.view3D,
                showHalo: simParams.view3D,
                earthRadius: EARTH_SCENE_RADIUS
            });
        }

        /* Moon */
        if (moon) updateMoon(moon, SIM_DATE, gmstNow);
    }

    function onWindowResize() {
        if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        if (mercatorContainer && mercatorContainer.style.display !== 'none' && mapBackgroundDiv) {
            const w = mapBackgroundDiv.clientWidth;
            const h = mapBackgroundDiv.clientHeight;
            if (mercatorCanvasElement.width !== w || mercatorCanvasElement.height !== h) {
                mercatorCanvasElement.width = w;
                mercatorCanvasElement.height = h;
            }
        }
    }
    window.addEventListener('resize', onWindowResize);

    async function start() {
        try {
            // ... (Previous initialization code: init3D, mercator, TLE loading) ...
            init3D();
            yprFrame = createYPRFrame(scene);
            setYPRVisibility(yprFrame, false);
            initMercatorView();
            initFootprintRenderer(scene, earthMesh, mercatorCtx);
            await setupTLESatellites(scene);

            setupHTMLControls();
            updateSatelliteList();
            updateECEFAxesVisibility(simParams);

            //initTimeline(satellites, simParams.simDate, handleTimelineSelection);

            initTimeline(satellites, (sat) => {
                console.log("Timeline Click:", sat.satellite_name);

                const dropdown = document.getElementById('satelliteSelect');
                const orbitFilter = document.getElementById('orbitTypeFilter');
                const companyFilter = document.getElementById('companyFilter');

                if (dropdown && orbitFilter && companyFilter) {
                    // 1. Force Reset Filters to ensure the satellite is available in the list
                    // Update UI elements
                    orbitFilter.value = 'ALL';
                    companyFilter.value = 'ALL COMPANY';

                    // Update Internal State (simParams comes from your main script scope)
                    simParams.orbitTypeFilter = 'ALL';
                    simParams.companyFilter = 'ALL COMPANY';

                    // 2. Refresh the dropdown list with the new filters
                    // This function (from your original code) repopulates the <select> options
                    updateSatelliteList();

                    // 3. Now that the option definitely exists, select it
                    dropdown.value = sat.satellite_name;

                    // 4. Trigger the standard selection logic
                    // We mimic a real "change" event
                    handleSatelliteDropdownChange({ target: dropdown });
                }
            });
            // =========================================================

            if (simParams.showOrbit && currentSelectedSatellite) {
                updateOrbitTrajectory(scene, simParams, currentSelectedSatellite);
            } else {
                simParams.showOrbit = false;
                const t = document.getElementById('showOrbitToggle');
                if (t) t.checked = false;
            }

            animate();
        } catch (e) {
            console.error("Critical error:", e);
        }
    }

    start();
</script>
</body>
</html>
