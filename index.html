<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Satellite Simulation - HTML Controls</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/arcazj/openbexi_earth_orbit/master/css/style.css">
    <style>
        /* Minimal inline styles, if any, specific to HTML structure before CSS loads */
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
        }

        canvas {
            display: block; /* Default for the main 3D canvas */
        }

        /* Menu Toggle Button */
        #menuToggleBtn {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1001; /* Above controls container */
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border: 1px solid #666;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            transition: left 0.3s ease-in-out;
        }

        /* Controls Container (Menu Panel) */
        #controlsContainer {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(40, 40, 40, 0.9);
            padding: 15px;
            border-radius: 8px;
            width: 280px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease-in-out;
            transform: translateX(0%); /* Initially visible */
        }

        #controlsContainer.menu-hidden {
            transform: translateX(calc(-100% - 20px)); /* Slide out completely */
        }

        /* Version Display within Menu */
        #versionDisplay {
            color: #888;
            font-size: 12px;
            text-align: center;
            padding: 5px 0 10px 0;
            border-bottom: 1px solid #555;
            margin-bottom: 10px;
            word-wrap: break-word; /* Ensure long links don't break layout */
        }

        #versionDisplay a {
            color: #00aaff; /* Link color */
            text-decoration: none;
        }

        #versionDisplay a:hover {
            text-decoration: underline;
        }

        /* Control Groups within Menu */
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #555;
        }

        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        /* Collapsible Section Headers (H3) */
        #controlsContainer h3 {
            color: #00aaff;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #controlsContainer h3 .toggle-icon {
            font-size: 12px;
            margin-left: 8px;
            transition: transform 0.2s ease-in-out;
        }

        #controlsContainer h3 .toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        /* Collapsible Content Styling */
        .collapsible-content {
            max-height: 500px; /* Large enough to show content */
            overflow: hidden;
            transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out, margin 0.3s ease-in-out;
        }

        .collapsible-content.collapsed {
            max-height: 0;
            padding-top: 0 !important; /* Ensure padding collapses */
            padding-bottom: 0 !important;
            margin-top: -10px; /* Adjust to pull up following element */
            border-top: none; /* Hide border if any was applied when open */
        }


        /* Labels for Controls */
        #controlsContainer label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 13px;
            color: #ccc;
        }

        /* Select Dropdowns */
        #controlsContainer select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #333;
            color: #fff;
            font-size: 13px;
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
        }

        /* Checkboxes */
        #controlsContainer input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle;
        }

        #controlsContainer .checkbox-label { /* Label next to a checkbox */
            display: inline-block;
            vertical-align: middle;
            font-weight: normal;
            color: #eee;
            cursor: pointer; /* Make the text label clickable for the checkbox */
        }

        /* Satellite Info Panel */
        #satelliteInfo {
            margin-top: 10px;
            color: #fff;
            font-family: monospace;
            background-color: #222;
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            white-space: pre-wrap; /* Preserve whitespace and newlines */
            border: 1px solid #444;
            max-height: 200px; /* Limit height and enable scroll if needed */
            overflow-y: auto;
        }

        /* Satellite Count Display */
        #satelliteCountDisplay {
            font-size: 13px;
            color: #00aaff;
            font-weight: bold;
        }

        /* Mercator Map Styling */
        #mercatorContainer {
            position: absolute;
            display: none; /* Hidden by default, JS controls visibility */
            pointer-events: auto; /* Allow interaction if needed for future features like map panning */
            border: 1px solid #555;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            /* Default to corner position */
            top: 10px;
            right: 10px;
            width: 400px;
            height: 200px;
            background-color: #111; /* Fallback if background image fails */
        }

        #mercatorContainer.fullscreen {
            top: 0;
            left: 0;
            right: auto; /* Override right positioning for fullscreen */
            width: 100vw;
            height: 100vh;
            border: none; /* No border in fullscreen */
            box-shadow: none; /* No shadow in fullscreen */
            z-index: 900; /* Below controls but above 3D canvas if it were visible */
        }

        .mapBackground {
            position: relative;
            width: 100%; /* Takes full width of its parent (#mercatorContainer) */
            height: 100%; /* Takes full height of its parent */
            /* background property will be set by JS attempting to load from GitHub */
            /* CSS fallback is applied via .fallback-css class if JS determines remote map texture fails */
            background-color: #2a2a2a; /* Default background if no image loads */
            background-repeat: no-repeat;
            background-size: 100% 100%; /* Ensure it covers the area */
        }

        #mercatorCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Fallback class applied by JS if remote image load fails for Mercator background */
        .mapBackground.fallback-css { /* This class is added by JS if GitHub image fails */
            background: #333 url('https://placehold.co/400x200/222222/ffffff?text=Map+Load+Error') no-repeat center center !important;
            background-size: contain !important; /* Use contain for placeholders to see text */
        }

        #mercatorContainer.fullscreen .mapBackground.fallback-css {
            background: #333 url('https://placehold.co/1920x1080/222222/ffffff?text=Map+Load+Error+Fullscreen') no-repeat center center !important;
            background-size: contain !important;
        }

    </style>
    <script src="https://unpkg.com/satellite.js@4.0.0/dist/satellite.min.js"></script>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
          }
        }
    </script>
</head>
<body>
<button id="menuToggleBtn">✕</button>
<div id="controlsContainer">
    <div id="versionDisplay"></div>
    <div class="control-group">
        <h3 data-collapsible-target="filtersContent">Filters <span class="toggle-icon">▾</span></h3>
        <div id="filtersContent" class="collapsible-content">
            <label for="orbitTypeFilter">Orbit Type:</label>
            <select id="orbitTypeFilter">
                <option value="ALL">ALL</option>
                <option value="LEO">LEO</option>
                <option value="MEO">MEO</option>
                <option value="GEO">GEO</option>
            </select>

            <label for="companyFilter">Company:</label>
            <select id="companyFilter">
                <option value="ALL COMPANY">ALL COMPANY</option>
            </select>

            <p>Satellites Found: <span id="satelliteCountDisplay">0</span></p>
        </div>
    </div>

    <div class="control-group">
        <h3 data-collapsible-target="viewContent">View <span class="toggle-icon">▾</span></h3>
        <div id="viewContent" class="collapsible-content">
            <input type="checkbox" id="view3DToggle" checked>
            <label for="view3DToggle" class="checkbox-label">3D Globe</label>
            <br>
            <input type="checkbox" id="viewMercatorToggle">
            <label for="viewMercatorToggle" class="checkbox-label">2D Mercator</label>
            <br>
            <input type="checkbox" id="highDefToggle">
            <label for="highDefToggle" class="checkbox-label">High Definition</label>
        </div>
    </div>

    <div class="control-group">
        <h3 data-collapsible-target="orbitExtrasContent">Orbit/Extras <span class="toggle-icon">▾</span></h3>
        <div id="orbitExtrasContent" class="collapsible-content">
            <input type="checkbox" id="showOrbitToggle">
            <label for="showOrbitToggle" class="checkbox-label">Show Orbit</label>
        </div>
    </div>

    <div class="control-group">
        <h3>Satellite Selection</h3>
        <div>
            <label for="satelliteSelect">Select Satellite:</label>
            <select id="satelliteSelect">
                <option value="None">None</option>
            </select>
            <div id="satelliteInfo">
                <div style="font-weight:bold;">No satellite selected</div>
            </div>
        </div>
    </div>
</div>

<div id="mercatorContainer">
    <div class="mapBackground">
        <canvas id="mercatorCanvas"></canvas>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

    const versionNumber = "1.0e";
    const versionRepoUrl = "https://github.com/arcazj/openbexi_earth_orbit";
    const versionText = `version ${versionNumber} - hosted at`;

    // Base URLs - these will be updated if GitHub fetch fails
    let GITHUB_REPO_RAW_BASE_URL = "https://raw.githubusercontent.com/arcazj/openbexi_earth_orbit/master/";
    let CONFIG_BASE_URL = GITHUB_REPO_RAW_BASE_URL + "config/";
    let TLE_BASE_URL = GITHUB_REPO_RAW_BASE_URL + "json/tle/";
    let usingLocalAssets = false; // Flag to indicate if we've switched to local assets

    let scene, camera, renderer, earthMesh, controls;
    let earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig;
    let globalScale;
    let mercatorCtx, mapWidth = 400, mapHeight = 200;
    let satellites = [];
    let orbitLine = null;
    let currentSelectedSatellite = null;
    let textureLoader;
    let mercatorSatIcon = new Image();
    let mercatorSatIconLoaded = false;

    const simParams = {
        orbitTypeFilter: "MEO",
        companyFilter: "ALL COMPANY",
        selectedSatellite: "None",
        showOrbit: false,
        view3D: true,
        viewMercator: false,
        useHighDefTexture: false
    };

    let orbitTypeFilterSelect, companyFilterSelect, satelliteCountDisplay;
    let view3DToggle, viewMercatorToggle, showOrbitToggle, highDefToggleElement;
    let satelliteSelectDropdown, satelliteInfoDiv;
    let mercatorContainer, mercatorCanvasElement, mapBackgroundDiv;
    let controlsContainerElement, menuToggleBtnElement, versionDisplayElement;

    function getFullGitHubUrl(relativePath) {
        if (!relativePath || typeof relativePath !== 'string') {
            console.warn("getFullGitHubUrl: received invalid path:", relativePath);
            return usingLocalAssets ? relativePath.replace(/^\//, '') : null;
        }
        if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
            return relativePath;
        }
        if (usingLocalAssets) {
            return relativePath.replace(/^\//, '');
        }
        return GITHUB_REPO_RAW_BASE_URL + relativePath.replace(/^\//, '');
    }

    function fetchJSON(url) {
        return fetch(url).then(resp => {
            if (!resp.ok) throw new Error(`Failed to load ${url}: ${resp.statusText} (Status: ${resp.status})`);
            return resp.json();
        }).catch(error => {
            console.error(`Error fetching JSON from ${url}:`, error.message); // Log only message for brevity
            if (url.includes('/tle/')) return [];
            return {};
        });
    }

    function isMobileDevice() {
        return /Android|iPhone|iPad|iPod|BlackBerry|Windows Phone/i.test(navigator.userAgent || navigator.vendor || window.opera);
    }

    async function loadConfigs() {
        console.log("Attempting to load configurations from GitHub:", CONFIG_BASE_URL);
        let primaryLoadSuccess = false;
        try {
            const results = await Promise.all([
                fetchJSON(CONFIG_BASE_URL + 'earth.json'),
                fetchJSON(CONFIG_BASE_URL + 'constants.json'),
                fetchJSON(CONFIG_BASE_URL + 'satellite.json'),
                fetchJSON(CONFIG_BASE_URL + 'scene.json'),
                fetchJSON(CONFIG_BASE_URL + 'controls.json')
            ]);
            [earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig] = results;

            if (!earthConfig || Object.keys(earthConfig).length === 0) {
                throw new Error("GitHub config load resulted in empty critical config (e.g., earth.json).");
            }
            console.log("Configurations loaded successfully from GitHub.");
            primaryLoadSuccess = true;

        } catch (githubError) {
            console.warn("GitHub configuration load failed:", githubError.message, "Attempting local fallback.");
            usingLocalAssets = true;
            GITHUB_REPO_RAW_BASE_URL = "";
            CONFIG_BASE_URL = "config/";
            TLE_BASE_URL = "json/tle/";

            // alert("Failed to load configurations from GitHub. Attempting to load from local paths..."); // User feedback

            try {
                const results = await Promise.all([
                    fetchJSON(CONFIG_BASE_URL + 'earth.json'),
                    fetchJSON(CONFIG_BASE_URL + 'constants.json'),
                    fetchJSON(CONFIG_BASE_URL + 'satellite.json'),
                    fetchJSON(CONFIG_BASE_URL + 'scene.json'),
                    fetchJSON(CONFIG_BASE_URL + 'controls.json')
                ]);
                [earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig] = results;

                if (!earthConfig || Object.keys(earthConfig).length === 0) {
                    throw new Error("Local config load also resulted in empty critical config.");
                }
                console.log("Configurations loaded successfully from local fallback.");
                primaryLoadSuccess = true; // Local load was successful
            } catch (localError) {
                console.error("Both GitHub and local configuration loads failed:", localError.message, "Using hardcoded fallbacks.");
                // Hardcoded fallbacks are applied below if primaryLoadSuccess is still false
            }
        }

        if (!primaryLoadSuccess) { // If both GitHub and local attempts failed
            earthConfig = { diameter: 12742, texture: 'textures/1_earth_16k.jpg', textureLight: 'textures/earthmap1k_light.jpg' };
            satelliteConfig = { icon: 'icons/ob_satellite.png', scale: [0.1, 0.1, 0.1], mercatorIcon: 'icons/ob_satellite.png' };
            sceneConfig = { camera: {fov: 45, near: 0.1, far: 1000, position: [0,0,30]}, ambientLight: {color:0xffffff, intensity:0.5}, directionalLight: {color:0xffffff, intensity:1, position:[5,3,5]}};
            controlsConfig = {enableDamping: true, dampingFactor: 0.05};
            constantsConfig = {};
            alert("Error loading configurations from all sources. Using default settings. App functionality may be limited.");
        }

        // Ensure defaults for critical properties after attempting loads
        earthConfig.diameter = earthConfig.diameter || 12742;
        earthConfig.texture = earthConfig.texture || 'textures/1_earth_16k.jpg';
        earthConfig.textureLight = earthConfig.textureLight || 'textures/earthmap1k_light.jpg';
        satelliteConfig.icon = satelliteConfig.icon || 'icons/ob_satellite.png';
        satelliteConfig.scale = satelliteConfig.scale || [0.1, 0.1, 0.1];
        satelliteConfig.mercatorIcon = satelliteConfig.mercatorIcon || 'icons/ob_satellite.png';
        sceneConfig.camera = sceneConfig.camera || {fov: 45, near: 0.1, far: 1000, position: [0,0,30]};
        sceneConfig.ambientLight = sceneConfig.ambientLight || {color:0xffffff, intensity:0.5};
        sceneConfig.directionalLight = sceneConfig.directionalLight || {color:0xffffff, intensity:1, position:[5,3,5]};
        controlsConfig.enableDamping = controlsConfig.enableDamping !== undefined ? controlsConfig.enableDamping : true;
        controlsConfig.dampingFactor = controlsConfig.dampingFactor || 0.05;

        globalScale = (earthConfig.diameter / 2) / 10;
    }

    function updateEarthTexture() {
        if (!earthMesh || !textureLoader || !earthConfig) {
            console.warn("updateEarthTexture: Missing critical components.");
            return;
        }

        const hdTextureFullUrl = getFullGitHubUrl(earthConfig.texture);
        const lightTextureFullUrl = getFullGitHubUrl(earthConfig.textureLight);
        const textureToLoad = simParams.useHighDefTexture ? hdTextureFullUrl : lightTextureFullUrl;

        if (!textureToLoad) {
            console.error("Earth Texture URL is null. Check config paths.");
            earthMesh.material.map = null;
            earthMesh.material.color.set(0x1a237e);
            earthMesh.material.needsUpdate = true;
            return;
        }
        console.log("Attempting to load Earth texture:", textureToLoad);

        textureLoader.load(textureToLoad,
            (texture) => {
                earthMesh.material.map = texture;
                earthMesh.material.color.set(0xffffff);
                earthMesh.material.needsUpdate = true;
                console.log("Earth texture successfully updated to:", textureToLoad);
            },
            undefined,
            (err) => {
                console.error('Error loading Earth texture from:', textureToLoad, err, '. Using placeholder.');
                const fallbackPlaceholder = `https://placehold.co/${simParams.useHighDefTexture ? '4096x2048' : '1024x512'}/1c313a/ffffff?text=Earth+Load+Error`;
                textureLoader.load(fallbackPlaceholder, (fallbackMap) => {
                    earthMesh.material.map = fallbackMap;
                    earthMesh.material.needsUpdate = true;
                });
            }
        );
    }

    function init3D() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(sceneConfig.camera.fov, window.innerWidth / window.innerHeight, sceneConfig.camera.near, sceneConfig.camera.far);
        camera.position.set(...sceneConfig.camera.position);
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(sceneConfig.ambientLight.color, sceneConfig.ambientLight.intensity));
        const dirLight = new THREE.DirectionalLight(sceneConfig.directionalLight.color, sceneConfig.directionalLight.intensity);
        dirLight.position.set(...sceneConfig.directionalLight.position);
        scene.add(dirLight);

        textureLoader = new THREE.TextureLoader();
        const earthMat = new THREE.MeshPhongMaterial({color: 0xffffff});
        earthMesh = new THREE.Mesh(new THREE.SphereGeometry(10, 64, 64), earthMat);
        scene.add(earthMesh);

        updateEarthTexture();

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = controlsConfig.enableDamping;
        controls.dampingFactor = controlsConfig.dampingFactor;
        controls.minDistance = 12;
        controls.maxDistance = 100;
    }

    function initMercatorView() {
        mercatorContainer = document.getElementById("mercatorContainer");
        mapBackgroundDiv = mercatorContainer.querySelector(".mapBackground");
        mercatorCanvasElement = document.getElementById("mercatorCanvas");

        mapWidth = mapBackgroundDiv.clientWidth;
        mapHeight = mapBackgroundDiv.clientHeight;
        mercatorCanvasElement.width = mapWidth;
        mercatorCanvasElement.height = mapHeight;
        mercatorCtx = mercatorCanvasElement.getContext("2d");

        const remoteMapBgUrl = getFullGitHubUrl('textures/earthmap1k.jpg');

        if (remoteMapBgUrl) {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                mapBackgroundDiv.style.backgroundImage = `url(${remoteMapBgUrl})`;
                mapBackgroundDiv.classList.remove('fallback-css');
                console.log("Mercator map background texture loaded:", remoteMapBgUrl);
            };
            img.onerror = () => {
                console.warn(`Mercator map background '${remoteMapBgUrl}' failed. Applying CSS fallback.`);
                mapBackgroundDiv.classList.add('fallback-css');
            };
            img.src = remoteMapBgUrl;
        } else {
            console.warn("Mercator map background URL is null. Applying CSS fallback.");
            mapBackgroundDiv.classList.add('fallback-css');
        }

        const mercatorIconFullUrl = getFullGitHubUrl(satelliteConfig.mercatorIcon || 'icons/ob_satellite.png');
        if (mercatorIconFullUrl) {
            mercatorSatIcon.crossOrigin = "Anonymous";
            mercatorSatIcon.onload = () => {
                mercatorSatIconLoaded = true;
                console.log("Mercator satellite icon loaded from:", mercatorSatIcon.src);
            };
            mercatorSatIcon.onerror = () => {
                console.error("Mercator satellite icon failed to load from:", mercatorIconFullUrl, ". Using placeholder.");
                mercatorSatIcon.src = 'https://placehold.co/16x16/ffffff/000000?text=S';
                mercatorSatIcon.onload = () => { mercatorSatIconLoaded = true; };
            };
            mercatorSatIcon.src = mercatorIconFullUrl;
        } else {
            console.error("Mercator satellite icon path is null. Using placeholder.");
            mercatorSatIcon.src = 'https://placehold.co/16x16/ffffff/000000?text=S';
            mercatorSatIcon.onload = () => { mercatorSatIconLoaded = true; };
        }
    }

    async function setupTLESatellites() {
        console.log("Attempting to load TLE data from:", TLE_BASE_URL); // TLE_BASE_URL is now correctly local or remote
        const primaryTleUrl = TLE_BASE_URL + 'TLE.json';

        try {
            let tleData = await fetchJSON(primaryTleUrl);

            if (!Array.isArray(tleData) || tleData.length === 0) {
                console.warn(`TLE data from ${primaryTleUrl} failed or is empty.`);
                if (usingLocalAssets) { // If already tried local and failed
                    alert("Critical Error: Failed to load any satellite TLE data (local attempt also failed). Satellites will not be displayed.");
                } else { // If GitHub attempt failed, now try local backup if specified (though loadConfigs should have switched TLE_BASE_URL)
                    const backupTleUrl = (GITHUB_REPO_RAW_BASE_URL || "") + "json/tle/" + 'TLE_backup.json'; // Construct backup URL carefully
                    console.log("Attempting backup TLE from:", backupTleUrl);
                    tleData = await fetchJSON(backupTleUrl);
                    if (!Array.isArray(tleData) || tleData.length === 0) {
                        alert("Critical Error: Failed to load any satellite TLE data from primary or backup. Satellites will not be displayed.");
                    } else {
                        console.log("Loaded TLE data from backup source.");
                    }
                }
                if (!Array.isArray(tleData) || tleData.length === 0) {
                    processSatellites([], null);
                    return;
                }
            }

            const satIconFullUrl = getFullGitHubUrl(satelliteConfig.icon || 'icons/ob_satellite.png');
            let satMaterial;

            if (!satIconFullUrl) {
                console.error("3D Satellite icon path is null. Using placeholder material.");
                satMaterial = new THREE.SpriteMaterial({
                    map: textureLoader.load('https://placehold.co/32x32/ff0000/ffffff?text=S_ERR')
                });
            } else {
                satMaterial = new THREE.SpriteMaterial({
                    map: textureLoader.load(satIconFullUrl, undefined,
                        () => { console.log("3D Satellite icon loaded from:", satIconFullUrl); },
                        (err) => {
                            console.error('Error loading 3D satellite icon from:', satIconFullUrl, err, '. Using placeholder.');
                            if (satMaterial) {
                                satMaterial.map = textureLoader.load('https://placehold.co/32x32/ff0000/ffffff?text=S');
                                satMaterial.needsUpdate = true;
                            }
                        })
                });
            }
            processSatellites(tleData, satMaterial);

        } catch(err) {
            console.error("Error in setupTLESatellites (fetching/processing):", err);
            alert("Error setting up satellite data. Check console.");
            processSatellites([], null);
        }
    }

    function processSatellites(tleData, baseMaterial) {
        satellites.forEach(s => { if (s.mesh) scene.remove(s.mesh); });
        satellites.length = 0;

        if (!tleData || tleData.length === 0) {
            console.warn("No TLE data to process.");
            if (typeof updateSatelliteList === "function") updateSatelliteList();
            return;
        }
        if (!baseMaterial) {
            console.error("Base material for satellites is not available. Cannot create sprites.");
            if (typeof updateSatelliteList === "function") updateSatelliteList();
            return;
        }

        tleData.forEach(item => {
            const {company, satellite_name, norad_id, type, launch_date, tle_line1, tle_line2} = item;
            if (!tle_line1 || !tle_line2) { console.warn(`Skipping ${satellite_name || norad_id}: missing TLE lines.`); return; }
            try {
                const satrec = satellite.twoline2satrec(tle_line1, tle_line2);
                if (!satrec) throw new Error("Failed to parse TLE.");

                const sprite = new THREE.Sprite(baseMaterial.clone());
                sprite.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
                scene.add(sprite);
                satellites.push({
                    mesh: sprite, satrec,
                    orbitType: type || "N/A",
                    company: company || "N/A",
                    satellite_name: satellite_name || `NORAD ${norad_id}`,
                    norad_id, launch_date, tle_line1, tle_line2
                });
            } catch (e) { console.error(`Error processing TLE for ${satellite_name || norad_id}: ${e.message}.`); }
        });
        console.log(`${satellites.length} satellites processed.`);
        if (typeof updateSatelliteList === "function") updateSatelliteList();
    }

    function setupHTMLControls() {
        controlsContainerElement = document.getElementById('controlsContainer');
        menuToggleBtnElement = document.getElementById('menuToggleBtn');
        versionDisplayElement = document.getElementById('versionDisplay');

        if(versionDisplayElement) {
            const versionLink = document.createElement('a');
            versionLink.href = versionRepoUrl;
            versionLink.textContent = `GitHub Repo`;
            versionLink.target = "_blank";
            versionDisplayElement.textContent = `${versionText} `;
            versionDisplayElement.appendChild(versionLink);
        }

        orbitTypeFilterSelect = document.getElementById('orbitTypeFilter');
        companyFilterSelect = document.getElementById('companyFilter');
        satelliteCountDisplay = document.getElementById('satelliteCountDisplay');
        view3DToggle = document.getElementById('view3DToggle');
        viewMercatorToggle = document.getElementById('viewMercatorToggle');
        highDefToggleElement = document.getElementById('highDefToggle');
        showOrbitToggle = document.getElementById('showOrbitToggle');
        satelliteSelectDropdown = document.getElementById('satelliteSelect');
        satelliteInfoDiv = document.getElementById('satelliteInfo');

        orbitTypeFilterSelect.value = simParams.orbitTypeFilter;
        view3DToggle.checked = simParams.view3D;
        viewMercatorToggle.checked = simParams.viewMercator;
        if(highDefToggleElement) highDefToggleElement.checked = simParams.useHighDefTexture;
        showOrbitToggle.checked = simParams.showOrbit;

        orbitTypeFilterSelect.addEventListener('change', (e) => {
            simParams.orbitTypeFilter = e.target.value;
            simParams.showOrbit = false; if(showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry(); updateSatelliteList();
        });
        companyFilterSelect.addEventListener('change', (e) => {
            simParams.companyFilter = e.target.value;
            simParams.showOrbit = false; if(showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry(); updateSatelliteList();
        });
        view3DToggle.addEventListener('change', (e) => simParams.view3D = e.target.checked);
        viewMercatorToggle.addEventListener('change', (e) => simParams.viewMercator = e.target.checked);

        if(highDefToggleElement) {
            highDefToggleElement.addEventListener('change', (e) => {
                simParams.useHighDefTexture = e.target.checked;
                updateEarthTexture();
            });
        }

        showOrbitToggle.addEventListener('change', (e) => {
            simParams.showOrbit = e.target.checked;
            if (currentSelectedSatellite) updateOrbitTrajectory(currentSelectedSatellite);
            else if (simParams.showOrbit) { simParams.showOrbit = false; e.target.checked = false; }
        });
        satelliteSelectDropdown.addEventListener('change', (e) => {
            simParams.selectedSatellite = e.target.value;
            const sat = satellites.find(s => s.satellite_name === e.target.value && s.mesh.visible);
            selectSatellite(sat || null);
        });

        document.querySelectorAll('#controlsContainer h3[data-collapsible-target]').forEach(header => {
            const targetId = header.dataset.collapsibleTarget;
            const targetContent = document.getElementById(targetId);
            const icon = header.querySelector('.toggle-icon');
            if (targetContent && icon) {
                targetContent.classList.remove('collapsed'); icon.classList.remove('collapsed'); icon.textContent = '▾';
                header.addEventListener('click', () => {
                    targetContent.classList.toggle('collapsed'); icon.classList.toggle('collapsed');
                    icon.textContent = targetContent.classList.contains('collapsed') ? '▸' : '▾';
                });
            }
        });

        if (menuToggleBtnElement && controlsContainerElement) {
            menuToggleBtnElement.addEventListener('click', () => {
                controlsContainerElement.classList.toggle('menu-hidden');
                menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕';
            });
            menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕';
        }
    }

    function updateSatelliteList() {
        if (!satellites || !satelliteSelectDropdown || !companyFilterSelect) {
            console.warn("updateSatelliteList: DOM elements not ready or satellites not loaded.");
            if(satelliteCountDisplay) satelliteCountDisplay.textContent = '0';
            if(satelliteSelectDropdown) satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
            if(companyFilterSelect) companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
            return;
        }

        const filtered = satellites.filter(s =>
            (simParams.orbitTypeFilter === "ALL" || s.orbitType === simParams.orbitTypeFilter) &&
            (simParams.companyFilter === "ALL COMPANY" || s.company === simParams.companyFilter)
        );
        satellites.forEach(s => {
            if (s.mesh) {
                const isVisible = filtered.includes(s);
                s.mesh.visible = isVisible;
                if (isVisible) {
                    s.mesh.material.color.set(s.isSelected ? 0xff0000 : 0xffffff);
                    s.mesh.scale.set(...(s.isSelected ? (satelliteConfig.scale || [0.1,0.1,0.1]).map(v => v * 1.5) : (satelliteConfig.scale || [0.1,0.1,0.1])));
                }
            }
        });
        if (currentSelectedSatellite && !filtered.includes(currentSelectedSatellite)) selectSatellite(null);

        if(satelliteCountDisplay) satelliteCountDisplay.textContent = filtered.length;

        const uniqueCompanies = Array.from(new Set(satellites.map(s => s.company))).sort();
        const currentCompanySelection = companyFilterSelect.value;
        companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
        uniqueCompanies.forEach(comp => {
            if(comp) {
                const option = document.createElement('option');
                option.value = comp; option.textContent = comp;
                companyFilterSelect.appendChild(option);
            }
        });
        if (uniqueCompanies.includes(currentCompanySelection)) {
            companyFilterSelect.value = currentCompanySelection;
        } else if (uniqueCompanies.length > 0 && simParams.companyFilter === "ALL COMPANY"){
            companyFilterSelect.value = "ALL COMPANY";
        } else if (uniqueCompanies.length > 0) {
            companyFilterSelect.value = uniqueCompanies[0];
            simParams.companyFilter = uniqueCompanies[0];
        } else {
            companyFilterSelect.value = "ALL COMPANY";
            simParams.companyFilter = "ALL COMPANY";
        }


        const currentDropdownValue = satelliteSelectDropdown.value;
        satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
        filtered.forEach(s => {
            const option = document.createElement('option');
            option.value = s.satellite_name; option.textContent = s.satellite_name;
            satelliteSelectDropdown.appendChild(option);
        });

        if (filtered.some(s => s.satellite_name === currentDropdownValue)) {
            satelliteSelectDropdown.value = currentDropdownValue;
        } else {
            satelliteSelectDropdown.value = "None";
            if (simParams.selectedSatellite !== "None") selectSatellite(null);
        }
        if (satelliteSelectDropdown.value === "None" && currentSelectedSatellite) selectSatellite(null);
    }

    function selectSatellite(sat) {
        if (currentSelectedSatellite && currentSelectedSatellite.mesh) {
            currentSelectedSatellite.isSelected = false;
            if (currentSelectedSatellite.mesh.visible) {
                currentSelectedSatellite.mesh.material.color.set(0xffffff);
                currentSelectedSatellite.mesh.scale.set(...(satelliteConfig.scale || [0.1,0.1,0.1]));
            }
        }
        currentSelectedSatellite = sat;
        if (sat && sat.mesh) {
            sat.isSelected = true;
            if (sat.mesh.visible) {
                sat.mesh.material.color.set(0xff0000);
                sat.mesh.scale.set(...(satelliteConfig.scale || [0.1,0.1,0.1]).map(v => v * 1.5));
            }
            simParams.selectedSatellite = sat.satellite_name;
            if(satelliteSelectDropdown) satelliteSelectDropdown.value = sat.satellite_name;
            updateOrbitTrajectory(sat);
        } else {
            simParams.selectedSatellite = "None";
            if(satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
            removeAllGeometry();
        }
        updateSatelliteInfo(sat);
    }

    function updateSatelliteInfo(sat) {
        if (!satelliteInfoDiv) return;
        if (!sat) { satelliteInfoDiv.innerHTML = `<div style="font-weight:bold;">No satellite selected</div>`; return; }
        satelliteInfoDiv.innerHTML = `
    <div style="font-weight:bold; margin-bottom:3px; color: #00aaff;">Selected: ${sat.satellite_name}</div>
    <div>Company: ${sat.company}</div><div>Type: ${sat.orbitType}</div>
    <div>Launch: ${sat.launch_date || "N/A"}</div><div>NORAD: ${sat.norad_id}</div>
    <div style="color:#aaa; margin-top:5px; font-size:10px;">TLE1: ${sat.tle_line1}</div>
    <div style="color:#aaa; font-size:10px;">TLE2: ${sat.tle_line2}</div>`;
    }

    function removeAllGeometry() {
        if (orbitLine) { scene.remove(orbitLine); orbitLine.geometry.dispose(); orbitLine.material.dispose(); orbitLine = null; }
    }

    function updateOrbitTrajectory(satData) {
        removeAllGeometry();
        if (!simParams.showOrbit || !satData || !satData.satrec) return;
        const meanMotion = satData.satrec.no; if (meanMotion === 0) { console.warn(`${satData.satellite_name} has zero mean motion.`); return; }
        const periodMins = 1440 / meanMotion;
        const segments = 14400; const step = periodMins / segments;
        const orbitPoints = []; const now = new Date();
        for (let i = 0; i <= segments; i++) {
            const future = new Date(now.getTime() + i * step * 60000);
            const posVel = satellite.propagate(satData.satrec, future);
            if (!posVel || !posVel.position) continue;
            const { x, y, z } = posVel.position;
            const kmToScene = 10 / 6371;
            orbitPoints.push(new THREE.Vector3(x * kmToScene, z * kmToScene, y * kmToScene));
        }
        if (orbitPoints.length < 2) { console.warn(`Not enough points for orbit: ${orbitPoints.length}`); return; }
        const geometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
        const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
        orbitLine = new THREE.Line(geometry, material); scene.add(orbitLine);
    }

    function animate() {
        requestAnimationFrame(animate);
        const now = new Date();
        const jdayNow = satellite.jday(now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
        const gmstNow = satellite.gstime(jdayNow);

        satellites.forEach(sat => {
            if (!sat.mesh || !sat.mesh.visible || !sat.satrec) return;
            try {
                const posVel = satellite.propagate(sat.satrec, now);
                if (!posVel || !posVel.position) return;
                const ecf = satellite.eciToEcf(posVel.position, gmstNow);
                const kmToScene = 10 / 6371;
                sat.mesh.position.set(ecf.x * kmToScene, ecf.z * kmToScene, ecf.y * kmToScene);
            } catch (e) { /* Silent error */ }
        });

        const show3D = simParams.view3D;
        const showMercator = simParams.viewMercator;

        if (renderer) renderer.domElement.style.display = (show3D) ? "block" : "none";

        if (mercatorContainer) {
            if (showMercator) {
                mercatorContainer.style.display = "block";
                if (!show3D) {
                    mercatorContainer.classList.add("fullscreen");
                } else {
                    mercatorContainer.classList.remove("fullscreen");
                }
                if (mercatorCanvasElement && mapBackgroundDiv) {
                    const currentMapContainerWidth = mapBackgroundDiv.clientWidth;
                    const currentMapContainerHeight = mapBackgroundDiv.clientHeight;
                    if (mercatorCanvasElement.width !== currentMapContainerWidth || mercatorCanvasElement.height !== currentMapContainerHeight) {
                        mercatorCanvasElement.width = currentMapContainerWidth;
                        mercatorCanvasElement.height = currentMapContainerHeight;
                    }
                    updateMercatorMap();
                }
            } else {
                mercatorContainer.style.display = "none";
            }
        }

        if (show3D && controls) controls.update();
        if (show3D && renderer && scene && camera) renderer.render(scene, camera);
    }

    function drawDayNightTerminatorMercator(ctx, width, height) {
        const now = new Date();
        const hoursUTC = now.getUTCHours() + now.getUTCMinutes() / 60;
        const subSolarLon = (hoursUTC * 15) - 180;
        const dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
        const N = dayOfYear;
        const declRad = -Math.asin(0.39779 * Math.cos(0.98565 * (N + 10) * Math.PI/180 + 1.914 * Math.sin(0.98565 * (N - 2) * Math.PI/180) * Math.PI/180));
        const subSolarLat = declRad * 180/Math.PI;

        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.35)";
        ctx.beginPath();

        const points = [];
        let firstPoint = null, lastPoint = null;

        for (let i = 0; i <= width; i++) {
            const lon = (i / width) * 360 - 180;
            let terminatorLat = Math.atan(-Math.cos((lon - subSolarLon) * Math.PI/180) / Math.tan(subSolarLat * Math.PI/180)) * 180/Math.PI;
            terminatorLat = Math.max(-85.05112878, Math.min(85.05112878, terminatorLat));
            const p = latLonToMercator(terminatorLat, lon);
            points.push(p);
            if (i === 0) firstPoint = p;
            if (i === width) lastPoint = p;
        }

        if (!firstPoint) { ctx.restore(); return; }

        ctx.moveTo(firstPoint.x, firstPoint.y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }

        if (subSolarLat > 0) {
            ctx.lineTo(lastPoint.x, height);
            ctx.lineTo(firstPoint.x, height);
        } else {
            ctx.lineTo(lastPoint.x, 0);
            ctx.lineTo(firstPoint.x, 0);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    function updateMercatorMap() {
        if (!mercatorCtx || !mercatorCanvasElement || mercatorContainer.style.display === 'none') return;

        mercatorCtx.clearRect(0, 0, mercatorCanvasElement.width, mercatorCanvasElement.height);

        if(typeof drawDayNightTerminatorMercator === 'function') {
            drawDayNightTerminatorMercator(mercatorCtx, mercatorCanvasElement.width, mercatorCanvasElement.height);
        }

        const now = new Date();
        const jdayNow = satellite.jday(now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
        const gmstNow = satellite.gstime(jdayNow);
        let labelPositions = [];

        const satDrawData = satellites
            .filter(sat => sat.mesh && sat.mesh.visible && sat.satrec)
            .map(sat => {
                try {
                    const posVel = satellite.propagate(sat.satrec, now);
                    if (!posVel || !posVel.position) return null;
                    const geo = satellite.eciToGeodetic(posVel.position, gmstNow);
                    const pt = latLonToMercator(satellite.degreesLat(geo.latitude), satellite.degreesLong(geo.longitude));
                    return { sat, pt, name: sat.satellite_name };
                } catch (e) { return null; }
            })
            .filter(Boolean)
            .sort((a,b) => a.pt.y - b.pt.y);

        satDrawData.forEach(data => {
            const { sat, pt, name } = data;
            const iconSize = 12;
            const leaderLength = 15;
            const textPadding = { x: 5, y: 3 };

            if (mercatorSatIconLoaded && mercatorSatIcon.complete && mercatorSatIcon.naturalHeight !== 0) {
                mercatorCtx.drawImage(mercatorSatIcon, pt.x - iconSize / 2, pt.y - iconSize / 2, iconSize, iconSize);
            } else {
                mercatorCtx.beginPath();
                mercatorCtx.arc(pt.x, pt.y, iconSize / 2, 0, 2 * Math.PI);
                mercatorCtx.fillStyle = sat.isSelected ? "rgba(255,0,0,0.8)" : "rgba(0,255,0,0.8)";
                mercatorCtx.fill();
            }

            mercatorCtx.font = sat.isSelected ? "bold 11px Arial" : "10px Arial";
            const textMetrics = mercatorCtx.measureText(name);
            const labelWidth = textMetrics.width + 2 * textPadding.x;
            const labelHeight = 12 + 2 * textPadding.y;

            const angles = [ -Math.PI / 4, -Math.PI / 2, -3 * Math.PI / 4, Math.PI, 3 * Math.PI / 4, Math.PI / 2, Math.PI / 4, 0 ];
            let bestPos = null;

            for (const angle of angles) {
                const leaderEndX = pt.x + (iconSize / 2 + leaderLength) * Math.cos(angle);
                const leaderEndY = pt.y + (iconSize / 2 + leaderLength) * Math.sin(angle);
                let textX = leaderEndX + ( (Math.cos(angle) >= 0 || Math.abs(Math.cos(angle)) < 0.1) ? textPadding.x : -labelWidth + textPadding.x );
                let textY = leaderEndY - labelHeight / 2;
                const currentLabelRect = { x: textX - textPadding.x, y: textY - textPadding.y, width: labelWidth, height: labelHeight };

                let isOverlapping = labelPositions.some(lp =>
                    currentLabelRect.x < lp.x + lp.width && currentLabelRect.x + currentLabelRect.width > lp.x &&
                    currentLabelRect.y < lp.y + lp.height && currentLabelRect.y + currentLabelRect.height > lp.y);

                if (!isOverlapping) { bestPos = { leaderEndX, leaderEndY, textX, textY, labelRect: currentLabelRect }; break; }
            }

            if (bestPos) {
                labelPositions.push(bestPos.labelRect);
                mercatorCtx.beginPath(); mercatorCtx.moveTo(pt.x, pt.y);
                mercatorCtx.lineTo(bestPos.leaderEndX, bestPos.leaderEndY);
                mercatorCtx.strokeStyle = "rgba(200, 200, 200, 0.7)"; mercatorCtx.lineWidth = 1; mercatorCtx.stroke();
                mercatorCtx.fillStyle = "rgba(0, 0, 0, 0.6)";
                mercatorCtx.fillRect(bestPos.labelRect.x, bestPos.labelRect.y, bestPos.labelRect.width, bestPos.labelRect.height);
                mercatorCtx.fillStyle = sat.isSelected ? "#ff8080" : "#00ddff";
                mercatorCtx.textAlign = "left"; mercatorCtx.textBaseline = "middle";
                mercatorCtx.fillText(name, bestPos.textX, bestPos.textY + labelHeight/2 - textPadding.y/2 +1);
            } else {
                mercatorCtx.fillStyle = sat.isSelected ? "#ff4444" : "#00aaff";
                mercatorCtx.textAlign = "center"; mercatorCtx.textBaseline = "bottom";
                mercatorCtx.fillText(name, pt.x, pt.y - iconSize/2 - 2);
            }
        });
    }

    function latLonToMercator(latDeg, lonDeg) {
        const currentWidth = mercatorCanvasElement ? mercatorCanvasElement.width : mapWidth;
        const currentHeight = mercatorCanvasElement ? mercatorCanvasElement.height : mapHeight;
        const x = (lonDeg + 180) * (currentWidth / 360);
        const clampedLatDeg = Math.max(-85.05112878, Math.min(85.05112878, latDeg));
        const latRad = clampedLatDeg * Math.PI / 180;
        const mercN = Math.log(Math.tan((Math.PI / 4) + (latRad / 2)));
        const y = (currentHeight / 2) - (currentWidth * mercN / (2 * Math.PI));
        return {x, y};
    }

    function onWindowResize() {
        if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }
    window.addEventListener('resize', onWindowResize);

    async function start() {
        try {
            await loadConfigs();
            init3D();
            initMercatorView();
            await setupTLESatellites();

            setupHTMLControls();
            updateSatelliteList();

            if (simParams.showOrbit && currentSelectedSatellite) {
                updateOrbitTrajectory(currentSelectedSatellite);
            } else {
                simParams.showOrbit = false;
                if (showOrbitToggle) showOrbitToggle.checked = false;
            }
            animate();
        } catch (e) {
            console.error("Critical error during initialization:", e);
            document.body.innerHTML = `<div style="color:red; padding:20px; font-family:monospace;"><h1>Initialization Failed</h1><pre>${e.stack || e.message}</pre><p>Check console and ensure remote resources (configs, TLEs, textures) are accessible on GitHub and paths are correct.</p></div>`;
        }
    }
    start();
</script>
</body>
</html>