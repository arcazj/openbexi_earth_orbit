<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Satellite Simulation – Filtering + Satellite Count</title>

    <style>
        body   { margin:0; overflow:hidden; }
        canvas { display:block; }
        /* Info panel inside lil‑gui */
        #satelliteInfo {
            margin-top:10px; color:#fff; font-family:monospace;
            background:#333; padding:5px; border-radius:5px;
            font-size:12px; white-space:pre-wrap;
        }
        /* 2‑D Mercator overlay */
        #mercatorContainer { position:absolute; top:0; left:0; display:none; pointer-events:none; }
        .mapBackground     { width:800px; height:400px; background:url(textures/earthmap1k.jpg) no-repeat; background-size:100% 100%; }
        #mercatorCanvas    { position:absolute; top:0; left:0; width:800px; height:400px; }
    </style>

    <!-- satellite.js (UMD) for quick TLE propagation -->
    <script src="https://unpkg.com/satellite.js@4.0.0/dist/satellite.min.js"></script>

    <!-- Import‑map so bare specifiers “three” and “three/addons/…” resolve correctly -->
    <script type="importmap">
        {
          "imports": {
            "three":            "https://unpkg.com/three@0.176.0/build/three.module.js",
            "three/addons/":    "https://unpkg.com/three@0.176.0/examples/jsm/"
          }
        }
    </script>
</head>

<body>
<!-- —————————————————— MAIN MODULE —————————————————— -->
<script type="module">
    /* ------------------------------------------------------------------
       ES‑module imports
       ------------------------------------------------------------------ */
    import * as THREE                     from 'three';
    import { OrbitControls }              from 'three/addons/controls/OrbitControls.js';
    import { GUI }                        from 'three/addons/libs/lil-gui.module.min.js';

    /* ------------------------------------------------------------------
       GLOBAL STATE
       ------------------------------------------------------------------ */
    let scene, camera, renderer, earthMesh, controls;
    let earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig;
    let globalScale;                       // km‑to‑scene scaling factor
    const satellites      = [];            // array of satellite objects
    let orbitLine = null;                  // current orbit line (if shown)
    let coverageCircle = null, visibilityCone = null;
    let currentSelectedSatellite = null;   // pointer to selected sat
    let satelliteController = null;        // dropdown controller (destroys/creates)

    /* ---- GUI state mirrors lil‑gui controls ---- */
    const guiParams = {
        orbitTypeFilter : 'MEO',       // default filter
        companyFilter   : 'ALL COMPANY',
        selectedSatellite : 'None',
        showOrbit       : false,
        view3D          : true,
        viewMercator    : false
    };
    const filterStats   = { satelliteCount: 0 }; // visible count

    /* ------------------------------------------------------------------
       UTILITY helpers
       ------------------------------------------------------------------ */
    const fetchJSON = url => fetch(url).then(r=>{
        if(!r.ok) throw new Error(`${url}: ${r.statusText}`); return r.json();
    });
    const isMobile = ()=>/Android|iPhone|iPad|iPod|BlackBerry|Windows Phone/i.test(navigator.userAgent);

    /* ------------------------------------------------------------------
       LOAD CONFIG FILES
       ------------------------------------------------------------------ */
    async function loadConfigs(){
        [ earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig ] =
            await Promise.all([
                fetchJSON('config/earth.json'),
                fetchJSON('config/constants.json'),
                fetchJSON('config/satellite.json'),
                fetchJSON('config/scene.json'),
                fetchJSON('config/controls.json')
            ]);
        globalScale = (earthConfig.diameter/2) / 10;   // Earth radius → 10 units
    }

    /* ------------------------------------------------------------------
       3‑D SCENE SETUP
       ------------------------------------------------------------------ */
    function init3D(){
        scene   = new THREE.Scene();

        camera  = new THREE.PerspectiveCamera(
            sceneConfig.camera.fov,
            window.innerWidth/window.innerHeight,
            sceneConfig.camera.near,
            sceneConfig.camera.far
        );
        camera.position.set(...sceneConfig.camera.position);

        renderer = new THREE.WebGLRenderer({ antialias:true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(sceneConfig.ambientLight.color, sceneConfig.ambientLight.intensity));
        const dl = new THREE.DirectionalLight(sceneConfig.directionalLight.color, sceneConfig.directionalLight.intensity);
        dl.position.set(...sceneConfig.directionalLight.position);
        scene.add(dl);

        const tex = new THREE.TextureLoader().load(isMobile()?earthConfig.textureLight:earthConfig.texture);
        earthMesh = new THREE.Mesh(new THREE.SphereGeometry(10,64,64), new THREE.MeshPhongMaterial({ map: tex }));
        scene.add(earthMesh);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = controlsConfig.enableDamping;
        controls.dampingFactor = controlsConfig.dampingFactor;
    }

    /* ------------------------------------------------------------------
       2‑D MERCATOR OVERLAY (hidden until viewMercator = true)
       ------------------------------------------------------------------ */
    let mercCtx, mapW = 800, mapH = 400;
    function initMercatorView(){
        const container = document.createElement('div');
        container.id='mercatorContainer';
        const mapDiv = Object.assign(document.createElement('div'),{className:'mapBackground'});
        const canvas = Object.assign(document.createElement('canvas'),{id:'mercatorCanvas',width:800,height:400});
        mapDiv.appendChild(canvas); container.appendChild(mapDiv); document.body.appendChild(container);
        mercCtx = canvas.getContext('2d');
    }

    /* ------------------------------------------------------------------
       TLE SATELLITE LOADING
       ------------------------------------------------------------------ */
    async function setupTLESatellites(path){
        const tle = await fetchJSON(path);
        const tex = new THREE.TextureLoader().load(satelliteConfig.icon);
        const baseMat = new THREE.SpriteMaterial({ map: tex });
        satellites.length = 0;

        tle.forEach(item=>{
            const satrec = satellite.twoline2satrec(item.tle_line1,item.tle_line2);
            const sprite = new THREE.Sprite(baseMat.clone());
            sprite.scale.set(...satelliteConfig.scale);
            scene.add(sprite);
            satellites.push({...item, satrec, mesh:sprite, isSelected:false});
        });
    }

    /* ------------------------------------------------------------------
       GUI CREATION – All controls live here
       ------------------------------------------------------------------ */
    let gui;                         // lil‑gui instance (created once)

    function createGUI(){
        gui = new GUI({ title:'Controls' });

        /* 1 — FILTER FOLDER ─────────────────────────────────────────── */
        const filterFolder = gui.addFolder('Filters');

        // Orbit‑type dropdown
        filterFolder.add(guiParams, 'orbitTypeFilter', ['ALL','LEO','MEO','GEO'])
            .name('Orbit Type')
            .onChange(()=>{                      // when user changes orbit‑type filter…
                guiParams.showOrbit = false;       //   hide any orbit line
                removeAllGeometry();
                updateSatelliteList();             //   rebuild dropdown & visibility
            });

        // Dynamically build company list once satellites are loaded
        let companies = satellites.map(s=>s.company);
        companies = Array.from(new Set(companies)).sort();
        companies.unshift('ALL COMPANY');
        filterFolder.add(guiParams,'companyFilter',companies)
            .name('Company')
            .onChange(()=>{ guiParams.showOrbit=false; removeAllGeometry(); updateSatelliteList(); });

        // Read‑only visible‑count display
        filterFolder.add(filterStats,'satelliteCount').name('Satellites Found').listen();
        filterFolder.open();

        /* 2 — VIEW FOLDER ───────────────────────────────────────────── */
        const viewFolder = gui.addFolder('View');
        viewFolder.add(guiParams,'view3D').name('3D Globe');           // toggled in animate()
        viewFolder.add(guiParams,'viewMercator').name('2D Mercator');  // toggled in animate()
        viewFolder.open();

        /* 3 — ORBIT / EXTRAS ────────────────────────────────────────── */
        const orbitFolder = gui.addFolder('Orbit Options');
        orbitFolder.add(guiParams,'showOrbit').name('Show Orbit').onChange(()=>{
            if(currentSelectedSatellite) updateOrbitTrajectory(currentSelectedSatellite);
        });
        orbitFolder.open();

        /* 4 — SATELLITE DROPDOWN ───────────────────────────────────── */
        updateSatelliteList();   // builds dropdown & info panel

        /* 5 — INFO PANEL ────────────────────────────────────────────── */
        let infoDiv = document.getElementById('satelliteInfo');
        if(!infoDiv){
            infoDiv = document.createElement('div'); infoDiv.id='satelliteInfo';
            gui.domElement.appendChild(infoDiv);
        }
    }

    /* ------------------------------------------------------------------
       Build / rebuild dropdown after any filter change
       ------------------------------------------------------------------ */
    function updateSatelliteList(){
        // Apply filters
        const filtered = satellites.filter(s=>{
            const okOrbit = guiParams.orbitTypeFilter==='ALL'||s.orbitType===guiParams.orbitTypeFilter;
            const okComp  = guiParams.companyFilter==='ALL COMPANY'||s.company===guiParams.companyFilter;
            return okOrbit && okComp;
        });

        // Reflect visibility on meshes
        satellites.forEach(s=>{
            s.mesh.visible = filtered.includes(s);
            s.mesh.material.color.set(0xffffff);
            s.mesh.scale.set(...satelliteConfig.scale);
            s.isSelected=false;
        });

        // Clear selection if not in filtered set
        if(currentSelectedSatellite && !filtered.includes(currentSelectedSatellite)){
            currentSelectedSatellite = null;
            guiParams.selectedSatellite='None';
            updateSatelliteInfo(null);
        }

        // Update visible count for GUI
        filterStats.satelliteCount = filtered.length;

        // (Re)create dropdown controller
        const names = ['None', ...filtered.map(s=>s.satellite_name)];
        if(satelliteController) satelliteController.destroy();
        guiParams.selectedSatellite='None';
        satelliteController = gui.add(guiParams,'selectedSatellite',names)
            .name('Select Satellite')
            .onChange(name=>{
                const sat = filtered.find(s=>s.satellite_name===name);
                sat ? selectSatellite(sat) : updateSatelliteInfo(null);
            });
    }

    /* ------------------------------------------------------------------
       WHEN USER SELECTS A SATELLITE IN DROPDOWN
       ------------------------------------------------------------------ */
    function selectSatellite(sat){
        currentSelectedSatellite = sat;
        satellites.forEach(s=>{
            s.mesh.material.color.set(0xffffff);
            s.mesh.scale.set(...satelliteConfig.scale);
            s.isSelected=false;
        });
        sat.isSelected = true;
        sat.mesh.material.color.set(0xff0000);               // highlight in red
        sat.mesh.scale.set(...satelliteConfig.scale.map(v=>v*1.5)); // enlarge

        updateSatelliteInfo(sat);                            // update info pane
        if(guiParams.showOrbit) updateOrbitTrajectory(sat);   // draw orbit if needed
    }

    /* ------------------------------------------------------------------
       Update INFO panel contents
       ------------------------------------------------------------------ */
    function updateSatelliteInfo(sat){
        const infoDiv = document.getElementById('satelliteInfo');
        if(!infoDiv) return;
        if(!sat){
            infoDiv.innerHTML = '<b>No satellite selected</b>';
            return;
        }
        infoDiv.innerHTML =
            `<b>Selected Satellite</b><br>
     Company: ${sat.company}<br>
     Name:    ${sat.satellite_name}<br>
     Type:    ${sat.orbitType}<br>
     Launch:  ${sat.launch_date||'N/A'}<br>
     NORAD ID:${sat.norad_id}<br><br>
     <span style="color:yellow">TLE Line 1:</span> ${sat.tle_line1}<br>
     <span style="color:yellow">TLE Line 2:</span> ${sat.tle_line2}`;
    }

    /* ------------------------------------------------------------------
       Remove any auxiliary geometry (orbit/coverage etc.)
       ------------------------------------------------------------------ */
    function removeAllGeometry(){
        if(orbitLine){ scene.remove(orbitLine); orbitLine=null; }
        if(coverageCircle){ scene.remove(coverageCircle); coverageCircle=null; }
        if(visibilityCone){ scene.remove(visibilityCone); visibilityCone=null; }
    }

    /* ------------------------------------------------------------------
       Draw ORBIT LINE for currently selected satellite
       ------------------------------------------------------------------ */
    function updateOrbitTrajectory(sat){
        removeAllGeometry();
        if(!guiParams.showOrbit) return;

        const meanMotion = sat.satrec.no;
        const periodMin  = 1440/meanMotion;
        const seg=14400, step=periodMin/seg, now=new Date(), km2=10/6371;
        const pts=[];
        for(let i=0;i<=seg;i++){
            const t = new Date(now.getTime()+i*step*60000);
            const pv=satellite.propagate(sat.satrec,t); if(!pv.position) continue;
            const {x,y,z}=pv.position; pts.push(new THREE.Vector3(x*km2,y*km2,z*km2));
        }
        orbitLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts),
            new THREE.LineBasicMaterial({color:0xff0000}));
        scene.add(orbitLine);
    }

    /* ------------------------------------------------------------------
       2‑D MERCATOR helpers (lat/lon → pixel, day/night terminator)
       ------------------------------------------------------------------ */
    function latLonToMercator(latDeg, lonDeg){
        const x = (lonDeg+180)*(mapW/360);
        const latRad = latDeg*Math.PI/180;
        const mercN = Math.log(Math.tan(Math.PI/4 + latRad/2));
        const y = (mapH/2) - (mapW*mercN/(2*Math.PI));
        return {x,y};
    }
    function wrapLon(l){while(l>180)l-=360; while(l<-180)l+=360; return l;}
    function dayOfYear(d){return Math.floor((d - new Date(d.getFullYear(),0,0))/(1000*60*60*24));}

    /* Draw simple day/night shading on Mercator map */
    function drawTerminator(){
        const ctx=mercCtx; ctx.fillStyle='rgba(0,0,0,0.4)';
        const now=new Date(), utc=now.getUTCHours()+now.getUTCMinutes()/60;
        const subLon=(utc*15)-180, decl=23.44*Math.sin((2*Math.PI/365)*(dayOfYear(now)-81));
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(mapW,0);
        for(let i=0;i<=36;i++){
            const frac=i/36, lat=decl+(frac*180-90), lon=subLon+180;
            const p=latLonToMercator(lat,wrapLon(lon)); ctx.lineTo(p.x,p.y);
        }
        ctx.lineTo(mapW,mapH); ctx.lineTo(0,mapH); ctx.closePath(); ctx.fill();
    }

    /* Refresh the Mercator overlay each frame (if enabled) */
    function updateMercatorMap(){
        mercCtx.clearRect(0,0,mapW,mapH);
        drawTerminator();

        const now=new Date(), j=satellite.jday(
            now.getUTCFullYear(),now.getUTCMonth()+1,now.getUTCDate(),
            now.getUTCHours(),now.getUTCMinutes(),now.getUTCSeconds());
        const gmst=satellite.gstime(j);

        satellites.forEach(s=>{
            if(!s.mesh.visible) return;
            const pv=satellite.propagate(s.satrec,now); if(!pv.position) return;
            const geo=satellite.eciToGeodetic(pv.position,gmst);
            const p=latLonToMercator(satellite.degreesLat(geo.latitude), satellite.degreesLong(geo.longitude));
            mercCtx.beginPath(); mercCtx.arc(p.x,p.y,4,0,2*Math.PI);
            mercCtx.fillStyle=s.isSelected?'#ff0000':'#00ff00'; mercCtx.fill();
            mercCtx.font='11px sans-serif'; mercCtx.fillStyle='#fff';
            mercCtx.fillText(s.satellite_name,p.x+6,p.y);
        });
    }

    /* ------------------------------------------------------------------
       ANIMATION LOOP
       ------------------------------------------------------------------ */
    function animate(){
        requestAnimationFrame(animate);

        // Update satellite mesh positions each frame
        const now=new Date(), km2=10/6371;
        satellites.forEach(s=>{
            if(!s.mesh.visible) return;
            const pv=satellite.propagate(s.satrec,now); if(!pv.position) return;
            const j=satellite.jday(now.getUTCFullYear(),now.getUTCMonth()+1,now.getUTCDate(),
                now.getUTCHours(),now.getUTCMinutes(),now.getUTCSeconds());
            const gmst=satellite.gstime(j);
            const ecf=satellite.eciToEcf(pv.position,gmst);
            s.mesh.position.set(ecf.x*km2, ecf.z*km2, ecf.y*km2);
        });

        // Show or hide renderer canvas depending on view mode
        if(guiParams.view3D){
            controls.update();
            renderer.domElement.style.display='block';
            renderer.render(scene,camera);
        }else{
            renderer.domElement.style.display='none';
        }

        // Update Mercator overlay if enabled
        document.getElementById('mercatorContainer').style.display =
            guiParams.viewMercator ? 'block':'none';
        if(guiParams.viewMercator) updateMercatorMap();
    }

    /* ------------------------------------------------------------------
       HANDLE RESIZE
       ------------------------------------------------------------------ */
    window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
    });

    /* ------------------------------------------------------------------
       MAIN ENTRY
       ------------------------------------------------------------------ */
    (async()=>{
        try{
            await loadConfigs();
            init3D();
            initMercatorView();
            await setupTLESatellites('json/tle/TLE.json');
            createGUI();
            updateSatelliteList();   // initial filter/GUI build
            animate();
        }catch(e){ console.error('init error:',e); }
    })();
</script>
</body>
</html>
