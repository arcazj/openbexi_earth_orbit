<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Satellite Simulation - HTML Controls</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <script src="https://unpkg.com/satellite.js@4.0.0/dist/satellite.min.js"></script>
    <script type="importmap">
        {
          "imports": {
             "three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/"
          }
        }
    </script>
</head>
<body>
<button id="menuToggleBtn">✕</button>
<div id="controlsContainer">
    <div id="versionDisplay"></div>
    <div class="control-group">
        <h3 data-collapsible-target="filtersContent">Filters <span class="toggle-icon">▾</span></h3>
        <div id="filtersContent" class="collapsible-content">
            <label for="orbitTypeFilter">Orbit Type:</label>
            <select id="orbitTypeFilter">
                <option value="ALL">ALL</option>
                <option value="LEO">LEO</option>
                <option value="MEO">MEO</option>
                <option value="GEO">GEO</option>
            </select>

            <label for="companyFilter">Company:</label>
            <select id="companyFilter">
                <option value="ALL COMPANY">ALL COMPANY</option>
            </select>

            <p>Satellites Found: <span id="satelliteCountDisplay">0</span></p>
        </div>
    </div>

    <div class="control-group">
        <h3 data-collapsible-target="viewContent">View <span class="toggle-icon">▾</span></h3>
        <div id="viewContent" class="collapsible-content">
            <input type="checkbox" id="view3DToggle" checked>
            <label for="view3DToggle" class="checkbox-label">3D Globe</label>
            <br>
            <input type="checkbox" id="viewMercatorToggle">
            <label for="viewMercatorToggle" class="checkbox-label">2D Mercator</label>
            <br>
            <input type="checkbox" id="highDefToggle">
            <label for="highDefToggle" class="checkbox-label">High Definition</label>
        </div>
    </div>

    <div class="control-group">
        <h3 data-collapsible-target="orbitExtrasContent">Orbit/Extras <span class="toggle-icon">▾</span></h3>
        <div id="orbitExtrasContent" class="collapsible-content">
            <input type="checkbox" id="showOrbitToggle">
            <label for="showOrbitToggle" class="checkbox-label">Show Orbit</label>
        </div>
    </div>

    <div class="control-group">
        <h3>Satellite Selection</h3>
        <div>
            <label for="satelliteSelect">Select Satellite:</label>
            <select id="satelliteSelect">
                <option value="None">None</option>
            </select>
            <div id="satelliteInfo">
                <div style="font-weight:bold;">No satellite selected</div>
            </div>
        </div>
    </div>
</div>

<div id="mercatorContainer">
    <div class="mapBackground">
        <canvas id="mercatorCanvas"></canvas>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

    // Version Constant (only the number now)
    const versionNumber = "1.0e";
    const versionRepoUrl = "https://github.com/arcazj/openbexi_earth_orbit";
    const versionText = `version ${versionNumber} - hosted at`;


    // GLOBALS
    let scene, camera, renderer, earthMesh, controls;
    let earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig;
    let globalScale;
    let mercatorCtx, mapWidth = 400, mapHeight = 200;
    let satellites = [];
    let orbitLine = null;
    let currentSelectedSatellite = null;
    let textureLoader;

    // Global variable for satellite icon image (Mercator)
    let mercatorSatIcon = new Image();
    mercatorSatIcon.src = satelliteConfig?.icon || 'icons/ob_satellite.png';
    mercatorSatIcon.onerror = () => {
        mercatorSatIcon.src = 'https://placehold.co/24x24/3333cc/ffffff?text=S';
    };


    // Parameters object
    const simParams = {
        orbitTypeFilter: "MEO",
        companyFilter: "ALL COMPANY",
        selectedSatellite: "None",
        showOrbit: false,
        view3D: true,
        viewMercator: false,
        useHighDefTexture: false
    };

    // HTML Element References
    let orbitTypeFilterSelect, companyFilterSelect, satelliteCountDisplay;
    let view3DToggle, viewMercatorToggle, showOrbitToggle, highDefToggleElement;
    let satelliteSelectDropdown, satelliteInfoDiv;
    let mercatorContainer, mercatorCanvasElement, mapBackgroundDiv;
    let controlsContainerElement, menuToggleBtnElement, versionDisplayElement;


    // UTILITY: fetchJSON
    function fetchJSON(url) {
        return fetch(url).then(resp => {
            if (!resp.ok) throw new Error(`Failed to load ${url}: ${resp.statusText}`);
            return resp.json();
        }).catch(error => {
            console.error(`Error fetching ${url}:`, error);
            if (url.endsWith('.json')) {
                if (url.includes('tle')) return [];
                return {};
            }
            throw error;
        });
    }

    // Utility function to detect mobile devices
    function isMobileDevice() {
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        return /Android|iPhone|iPad|iPod|BlackBerry|Windows Phone/i.test(userAgent);
    }

    // LOAD CONFIGS
    async function loadConfigs() {
        try {
            [earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig] = await Promise.all([
                fetchJSON('config/earth.json'), fetchJSON('config/constants.json'),
                fetchJSON('config/satellite.json'), fetchJSON('config/scene.json'),
                fetchJSON('config/controls.json')
            ]);
            earthConfig = earthConfig || {};
            earthConfig.diameter = earthConfig.diameter || 12742;
            earthConfig.texture = earthConfig.texture || 'textures/1_earth_16k.jpg';
            earthConfig.textureLight = earthConfig.textureLight || 'textures/earthmap1k_light.jpg';

            satelliteConfig = satelliteConfig || {icon: 'textures/satellite_icon.png', scale: [0.1, 0.1, 0.1]};
            sceneConfig = sceneConfig || {
                camera: {fov: 45, near: 0.1, far: 1000, position: [0, 0, 30]},
                ambientLight: {color: 0xffffff, intensity: 0.5},
                directionalLight: {color: 0xffffff, intensity: 1, position: [5, 3, 5]}
            };
            controlsConfig = controlsConfig || {enableDamping: true, dampingFactor: 0.05};
            globalScale = (earthConfig.diameter / 2) / 10;
        } catch (error) {
            console.error("Failed to load configurations:", error);
            earthConfig = {
                diameter: 12742,
                texture: 'https://placehold.co/4096x2048/000099/ffffff?text=Earth+HD+Error',
                textureLight: 'https://placehold.co/1024x512/0000ff/ffffff?text=Earth+SD+Error'
            };
            satelliteConfig = {icon: 'https://placehold.co/32x32/ff0000/ffffff?text=Sat', scale: [0.1, 0.1, 0.1]};
            sceneConfig = {
                camera: {fov: 45, near: 0.1, far: 1000, position: [0, 0, 30]},
                ambientLight: {color: 0xffffff, intensity: 0.5},
                directionalLight: {color: 0xffffff, intensity: 1, position: [5, 3, 5]}
            };
            controlsConfig = {enableDamping: true, dampingFactor: 0.05};
            globalScale = (earthConfig.diameter / 2) / 10;
            alert("Error loading configurations. Using default settings.");
        }
    }

    // FUNCTION TO UPDATE EARTH TEXTURE
    function updateEarthTexture() {
        if (!earthMesh || !textureLoader || !earthConfig) return;

        const textureUrl = simParams.useHighDefTexture ? earthConfig.texture : earthConfig.textureLight;
        console.log("Loading Earth texture:", textureUrl);

        textureLoader.load(textureUrl, (texture) => {
            earthMesh.material.map = texture;
            earthMesh.material.needsUpdate = true;
            console.log("Earth texture updated to:", textureUrl);
        }, undefined, (err) => {
            console.error('Error loading Earth texture:', textureUrl, err, '. Using fallback.');
            const fallbackTextureUrl = simParams.useHighDefTexture ? 'https://placehold.co/4096x2048/111155/ffffff?text=HD+Load+Error' : 'https://placehold.co/1024x512/222266/ffffff?text=SD+Load+Error';
            textureLoader.load(fallbackTextureUrl, (fallbackMap) => {
                earthMesh.material.map = fallbackMap;
                earthMesh.material.needsUpdate = true;
            });
        });
    }


    // INIT 3D SCENE
    function init3D() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(sceneConfig.camera.fov, window.innerWidth / window.innerHeight, sceneConfig.camera.near, sceneConfig.camera.far);
        camera.position.set(...sceneConfig.camera.position);
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(sceneConfig.ambientLight.color, sceneConfig.ambientLight.intensity));
        const dirLight = new THREE.DirectionalLight(sceneConfig.directionalLight.color, sceneConfig.directionalLight.intensity);
        dirLight.position.set(...sceneConfig.directionalLight.position);
        scene.add(dirLight);

        textureLoader = new THREE.TextureLoader();
        const earthMat = new THREE.MeshPhongMaterial();
        earthMesh = new THREE.Mesh(new THREE.SphereGeometry(10, 64, 64), earthMat);
        scene.add(earthMesh);

        updateEarthTexture();

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = controlsConfig.enableDamping;
        controls.dampingFactor = controlsConfig.dampingFactor;
    }

    // INIT 2D MERCATOR VIEW
    function initMercatorView() {
        mercatorContainer = document.getElementById("mercatorContainer");
        mapBackgroundDiv = mercatorContainer.querySelector(".mapBackground");
        mercatorCanvasElement = document.getElementById("mercatorCanvas");

        mapWidth = mapBackgroundDiv.clientWidth;
        mapHeight = mapBackgroundDiv.clientHeight;
        mercatorCanvasElement.width = mapWidth;
        mercatorCanvasElement.height = mapHeight;
        mercatorCtx = mercatorCanvasElement.getContext("2d");

        const primaryMapTextureUrl = 'textures/earthmap1k.jpg';
        const img = new Image();
        img.src = primaryMapTextureUrl;
        img.onload = () => {
            mapBackgroundDiv.classList.remove('fallback');
            console.log("Mercator map texture loaded.");
        };
        img.onerror = () => {
            console.warn(`Mercator map texture '${primaryMapTextureUrl}' failed. Fallback applied.`);
            mapBackgroundDiv.classList.add('fallback');
        };
    }

    // SETUP TLE SATELLITES
    async function setupTLESatellites(jsonFilePath) {
        try {
            let tleData = await fetchJSON(jsonFilePath);
            if ((!Array.isArray(tleData) || tleData.length === 0) && jsonFilePath === 'json/tle/TLE.json') {
                const backupTleData = await fetchJSON('json/tle/TLE_backup.json');
                if (backupTleData && backupTleData.length > 0) {
                    tleData = backupTleData;
                    alert("Primary TLE failed. Loaded backup.");
                } else {
                    console.error("All TLE data sources failed.");
                    alert("Critical Error: No satellite data.");
                    return;
                }
            }
            const satTextureLoader = new THREE.TextureLoader();
            const satIconUrl = satelliteConfig.icon || 'https://placehold.co/32x32/ff0000/ffffff?text=S_Icon';
            const baseMaterial = new THREE.SpriteMaterial({
                map: satTextureLoader.load(satIconUrl, undefined, () => {
                }, (err) => {
                    console.error('Error loading satellite icon:', err, '. Using fallback.');
                    baseMaterial.map = satTextureLoader.load('https://placehold.co/32x32/ff0000/ffffff?text=S');
                    baseMaterial.needsUpdate = true;
                })
            });
            satellites.forEach(s => scene.remove(s.mesh));
            satellites.length = 0;
            tleData.forEach(item => {
                const {company, satellite_name, norad_id, type, launch_date, tle_line1, tle_line2} = item;
                if (!tle_line1 || !tle_line2) {
                    console.warn(`Skipping ${satellite_name || norad_id}: missing TLE.`);
                    return;
                }
                try {
                    const satrec = satellite.twoline2satrec(tle_line1, tle_line2);
                    if (!satrec) throw new Error("Failed to parse TLE.");
                    const sprite = new THREE.Sprite(baseMaterial.clone());
                    sprite.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
                    scene.add(sprite);
                    satellites.push({
                        mesh: sprite,
                        satrec,
                        orbitType: type || "N/A",
                        company: company || "N/A",
                        satellite_name: satellite_name || `NORAD ${norad_id}`,
                        norad_id,
                        launch_date,
                        tle_line1,
                        tle_line2
                    });
                } catch (e) {
                    console.error(`Error processing TLE for ${satellite_name || norad_id}: ${e.message}.`);
                }
            });
        } catch (err) {
            console.error("Error in setupTLESatellites:", err);
            alert("Error setting up satellite data.");
        }
    }

    // SETUP HTML CONTROLS
    function setupHTMLControls() {
        controlsContainerElement = document.getElementById('controlsContainer');
        menuToggleBtnElement = document.getElementById('menuToggleBtn');
        versionDisplayElement = document.getElementById('versionDisplay');

        // Setup version display with link
        if (versionDisplayElement) {
            const versionLink = document.createElement('a');
            versionLink.href = versionRepoUrl;
            versionLink.textContent = `GitHub Repo`;
            versionLink.target = "_blank"; // Open in new tab
            versionDisplayElement.textContent = `${versionText} `; // Add space before link
            versionDisplayElement.appendChild(versionLink);
        }


        orbitTypeFilterSelect = document.getElementById('orbitTypeFilter');
        companyFilterSelect = document.getElementById('companyFilter');
        satelliteCountDisplay = document.getElementById('satelliteCountDisplay');
        view3DToggle = document.getElementById('view3DToggle');
        viewMercatorToggle = document.getElementById('viewMercatorToggle');
        highDefToggleElement = document.getElementById('highDefToggle');
        showOrbitToggle = document.getElementById('showOrbitToggle');
        satelliteSelectDropdown = document.getElementById('satelliteSelect');
        satelliteInfoDiv = document.getElementById('satelliteInfo');

        orbitTypeFilterSelect.value = simParams.orbitTypeFilter;
        view3DToggle.checked = simParams.view3D;
        viewMercatorToggle.checked = simParams.viewMercator;
        if (highDefToggleElement) highDefToggleElement.checked = simParams.useHighDefTexture;
        showOrbitToggle.checked = simParams.showOrbit;

        let companies = Array.from(new Set(satellites.map(s => s.company))).sort();
        companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
        companies.forEach(comp => {
            const option = document.createElement('option');
            option.value = comp;
            option.textContent = comp;
            companyFilterSelect.appendChild(option);
        });
        companyFilterSelect.value = simParams.companyFilter;

        orbitTypeFilterSelect.addEventListener('change', (e) => {
            simParams.orbitTypeFilter = e.target.value;
            simParams.showOrbit = false;
            showOrbitToggle.checked = false;
            removeAllGeometry();
            updateSatelliteList();
        });
        companyFilterSelect.addEventListener('change', (e) => {
            simParams.companyFilter = e.target.value;
            simParams.showOrbit = false;
            showOrbitToggle.checked = false;
            removeAllGeometry();
            updateSatelliteList();
        });
        view3DToggle.addEventListener('change', (e) => simParams.view3D = e.target.checked);
        viewMercatorToggle.addEventListener('change', (e) => simParams.viewMercator = e.target.checked);

        if (highDefToggleElement) {
            highDefToggleElement.addEventListener('change', (e) => {
                simParams.useHighDefTexture = e.target.checked;
                updateEarthTexture();
            });
        }

        showOrbitToggle.addEventListener('change', (e) => {
            simParams.showOrbit = e.target.checked;
            if (currentSelectedSatellite) updateOrbitTrajectory(currentSelectedSatellite);
            else if (simParams.showOrbit) {
                simParams.showOrbit = false;
                e.target.checked = false;
            }
        });
        satelliteSelectDropdown.addEventListener('change', (e) => {
            simParams.selectedSatellite = e.target.value;
            const sat = satellites.find(s => s.satellite_name === e.target.value && s.mesh.visible);
            selectSatellite(sat || null);
        });

        document.querySelectorAll('#controlsContainer h3[data-collapsible-target]').forEach(header => {
            const targetId = header.dataset.collapsibleTarget;
            const targetContent = document.getElementById(targetId);
            const icon = header.querySelector('.toggle-icon');
            if (targetContent && icon) {
                targetContent.classList.remove('collapsed');
                icon.classList.remove('collapsed');
                icon.textContent = '▾';
                header.addEventListener('click', () => {
                    targetContent.classList.toggle('collapsed');
                    icon.classList.toggle('collapsed');
                    icon.textContent = targetContent.classList.contains('collapsed') ? '▸' : '▾';
                });
            }
        });

        if (menuToggleBtnElement && controlsContainerElement) {
            menuToggleBtnElement.addEventListener('click', () => {
                controlsContainerElement.classList.toggle('menu-hidden');
                menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕';
            });
            menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕';
        }
    }

    // UPDATE SATELLITE LIST
    function updateSatelliteList() {
        const filtered = satellites.filter(s =>
            (simParams.orbitTypeFilter === "ALL" || s.orbitType === simParams.orbitTypeFilter) &&
            (simParams.companyFilter === "ALL COMPANY" || s.company === simParams.companyFilter)
        );
        satellites.forEach(s => {
            const isVisible = filtered.includes(s);
            s.mesh.visible = isVisible;
            if (isVisible) {
                s.mesh.material.color.set(s.isSelected ? 0xff0000 : 0xffffff);
                s.mesh.scale.set(...(s.isSelected ? (satelliteConfig.scale || [0.1, 0.1, 0.1]).map(v => v * 1.5) : (satelliteConfig.scale || [0.1, 0.1, 0.1])));
            }
        });
        if (currentSelectedSatellite && !filtered.includes(currentSelectedSatellite)) selectSatellite(null);
        if (satelliteCountDisplay) satelliteCountDisplay.textContent = filtered.length;

        const currentDropdownValue = satelliteSelectDropdown.value;
        satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
        filtered.forEach(s => {
            const option = document.createElement('option');
            option.value = s.satellite_name;
            option.textContent = s.satellite_name;
            satelliteSelectDropdown.appendChild(option);
        });
        if (filtered.some(s => s.satellite_name === currentDropdownValue)) satelliteSelectDropdown.value = currentDropdownValue;
        else {
            satelliteSelectDropdown.value = "None";
            if (simParams.selectedSatellite !== "None") selectSatellite(null);
        }
        if (satelliteSelectDropdown.value === "None" && currentSelectedSatellite) selectSatellite(null);
    }

    // SELECT SATELLITE
    function selectSatellite(sat) {
        if (currentSelectedSatellite) {
            currentSelectedSatellite.isSelected = false;
            if (currentSelectedSatellite.mesh.visible) {
                currentSelectedSatellite.mesh.material.color.set(0xffffff);
                currentSelectedSatellite.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
            }
        }
        currentSelectedSatellite = sat;
        if (sat) {
            sat.isSelected = true;
            if (sat.mesh.visible) {
                sat.mesh.material.color.set(0xff0000);
                sat.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]).map(v => v * 3.5));
            }
            simParams.selectedSatellite = sat.satellite_name;
            satelliteSelectDropdown.value = sat.satellite_name;
            updateOrbitTrajectory(sat);
        } else {
            simParams.selectedSatellite = "None";
            satelliteSelectDropdown.value = "None";
            removeAllGeometry();
        }
        updateSatelliteInfo(sat);
    }

    // UPDATE SATELLITE INFO PANEL
    function updateSatelliteInfo(sat) {
        if (!satelliteInfoDiv) return;
        if (!sat) {
            satelliteInfoDiv.innerHTML = `<div style="font-weight:bold;">No satellite selected</div>`;
            return;
        }
        satelliteInfoDiv.innerHTML = `
    <div style="font-weight:bold; margin-bottom:3px; color: #00aaff;">Selected: ${sat.satellite_name}</div>
    <div>Company: ${sat.company}</div><div>Type: ${sat.orbitType}</div>
    <div>Launch: ${sat.launch_date || "N/A"}</div><div>NORAD: ${sat.norad_id}</div>
    <div style="color:#aaa; margin-top:5px; font-size:10px;">TLE1: ${sat.tle_line1}</div>
    <div style="color:#aaa; font-size:10px;">TLE2: ${sat.tle_line2}</div>`;
    }

    // REMOVE GEOMETRY
    function removeAllGeometry() {
        if (orbitLine) {
            scene.remove(orbitLine);
            orbitLine.geometry.dispose();
            orbitLine.material.dispose();
            orbitLine = null;
        }
    }

    // UPDATE ORBIT TRAJECTORY
    function updateOrbitTrajectory(satData) {
        removeAllGeometry();
        if (!simParams.showOrbit || !satData || !satData.satrec) return;
        const meanMotion = satData.satrec.no;
        if (meanMotion === 0) {
            console.warn(`${satData.satellite_name} has zero mean motion.`);
            return;
        }
        const periodMins = 1440 / meanMotion;
        const segments = 14400;
        const step = periodMins / segments;
        const orbitPoints = [];
        const now = new Date();
        for (let i = 0; i <= segments; i++) {
            const future = new Date(now.getTime() + i * step * 60000);
            const posVel = satellite.propagate(satData.satrec, future);
            if (!posVel || !posVel.position) continue;
            const {x, y, z} = posVel.position;
            const kmToScene = 10 / 6371;
            orbitPoints.push(new THREE.Vector3(x * kmToScene, z * kmToScene, y * kmToScene));
        }
        if (orbitPoints.length < 2) {
            console.warn(`Not enough points for orbit: ${orbitPoints.length}`);
            return;
        }
        const geometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
        const material = new THREE.LineBasicMaterial({color: 0xff0000});
        orbitLine = new THREE.Line(geometry, material);
        scene.add(orbitLine);
    }

    // ANIMATION LOOP
    function animate() {
        requestAnimationFrame(animate);
        const now = new Date();
        const jdayNow = satellite.jday(now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
        const gmstNow = satellite.gstime(jdayNow);

        satellites.forEach(sat => {
            if (!sat.mesh.visible || !sat.satrec) return;
            try {
                const posVel = satellite.propagate(sat.satrec, now);
                if (!posVel || !posVel.position) return;
                const ecf = satellite.eciToEcf(posVel.position, gmstNow);
                const kmToScene = 10 / 6371;
                sat.mesh.position.set(ecf.x * kmToScene, ecf.z * kmToScene, ecf.y * kmToScene);
            } catch (e) { /* Silent error for propagation issues */
            }
        });

        const show3D = simParams.view3D;
        const showMercator = simParams.viewMercator;

        if (show3D && !showMercator) {
            if (renderer) renderer.domElement.style.display = "block";
            if (mercatorContainer) mercatorContainer.style.display = "none";
        } else if (!show3D && showMercator) {
            if (renderer) renderer.domElement.style.display = "none";
            if (mercatorContainer) {
                mercatorContainer.style.display = "block";
                mercatorContainer.classList.add("fullscreen");
            }
        } else if (show3D && showMercator) {
            if (renderer) renderer.domElement.style.display = "block";
            if (mercatorContainer) {
                mercatorContainer.style.display = "block";
                mercatorContainer.classList.remove("fullscreen");
            }
        } else {
            if (renderer) renderer.domElement.style.display = "none";
            if (mercatorContainer) mercatorContainer.style.display = "none";
        }

        if (showMercator && mercatorCanvasElement && mapBackgroundDiv) {
            const currentMapContainerWidth = mapBackgroundDiv.clientWidth;
            const currentMapContainerHeight = mapBackgroundDiv.clientHeight;
            if (mercatorCanvasElement.width !== currentMapContainerWidth || mercatorCanvasElement.height !== currentMapContainerHeight) {
                mercatorCanvasElement.width = currentMapContainerWidth;
                mercatorCanvasElement.height = currentMapContainerHeight;
            }
            updateMercatorMap();
        }

        if (show3D && controls) controls.update();
        if (show3D && renderer && scene && camera) renderer.render(scene, camera);
    }

    function drawDayNightTerminatorMercator(ctx, width, height) {
        const now = new Date();
        // Calculate subsolar longitude and latitude (declination)
        const hoursUTC = now.getUTCHours() + now.getUTCMinutes() / 60;
        const subSolarLon = (hoursUTC * 15) - 180; // -180 at midnight UTC, +180 at noon UTC
        const dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
        const decl = 23.44 * Math.sin((2 * Math.PI / 365) * (dayOfYear - 81)); // Subsolar latitude
        const subSolarLat = decl;

        // Draw the night overlay as a polygon following the terminator
        ctx.save();
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(width, 0);
        // Sample points across the longitude
        const segments = 120;
        for (let i = 0; i <= segments; i++) {
            const frac = i / segments;
            const lon = -180 + frac * 360;
            // Approximate: latitude at night boundary at this longitude
            // The night hemisphere is ~90° from the subsolar point
            let lat = Math.asin(
                -Math.cos((lon - subSolarLon) * Math.PI / 180) * Math.cos(subSolarLat * Math.PI / 180)
            ) * 180 / Math.PI;
            // Map to y in Mercator
            const y = ((height / 2) - (width * Math.log(Math.tan((Math.PI / 4) + (lat * Math.PI / 360))) / (2 * Math.PI)));
            const x = frac * width;
            ctx.lineTo(x, y);
        }
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.closePath();
        ctx.fillStyle = "#000";
        ctx.fill();
        ctx.restore();
    }

    // 2D MERCATOR MAP UPDATE
    function updateMercatorMap() {
        if (!mercatorCtx || !mercatorCanvasElement || mercatorContainer.style.display === 'none') return;

        mercatorCtx.clearRect(0, 0, mercatorCanvasElement.width, mercatorCanvasElement.height);
        const now = new Date();
        const jdayNow = satellite.jday(now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
        const gmstNow = satellite.gstime(jdayNow);

        // We'll keep track of all label positions to avoid overlaps
        let labelRows = [];

        // 1. Project satellites to Mercator map and sort by y (latitude)
        let mappedSats = satellites
            .filter(sat => sat.mesh.visible && sat.satrec)
            .map(sat => {
                try {
                    const posVel = satellite.propagate(sat.satrec, now);
                    if (!posVel || !posVel.position) return null;
                    const geo = satellite.eciToGeodetic(posVel.position, gmstNow);
                    const pt = latLonToMercator(
                        satellite.degreesLat(geo.latitude),
                        satellite.degreesLong(geo.longitude)
                    );
                    return { sat, pt };
                } catch (e) { return null; }
            })
            .filter(Boolean)
            .sort((a, b) => a.pt.y - b.pt.y); // Top-to-bottom

        mappedSats.forEach(({ sat, pt }) => {
            // Draw satellite icon (centered)
            let iconW = 18, iconH = 18;
            mercatorCtx.drawImage(
                mercatorSatIcon,
                pt.x - iconW / 2,
                pt.y - iconH / 2,
                iconW,
                iconH
            );

            // Decide label position: default 30px above, but avoid overlap
            let labelY = pt.y - 30;
            let labelX = pt.x + 8 + iconW / 2; // 8px right of icon
            let name = sat.satellite_name;

            // Check for overlap with previous labels
            for (let attempt = 0; attempt < 2; attempt++) {
                let overlap = labelRows.some(r =>
                    Math.abs(r.x - labelX) < 60 && Math.abs(r.y - labelY) < 18
                );
                if (!overlap) break;
                // If overlap, put it below instead of above
                labelY = pt.y + 30;
            }
            labelRows.push({ x: labelX, y: labelY });

            // Draw leader line from icon to label
            mercatorCtx.save();
            mercatorCtx.strokeStyle = "#aaa";
            mercatorCtx.lineWidth = 1;
            mercatorCtx.beginPath();
            mercatorCtx.moveTo(pt.x, pt.y + (labelY > pt.y ? iconH/2 : -iconH/2)); // From top/bottom of icon
            mercatorCtx.lineTo(labelX - 4, labelY + 7); // To left edge of label text
            mercatorCtx.stroke();
            mercatorCtx.restore();

            // Draw label text
            mercatorCtx.font = sat.isSelected ? "bold 12px sans-serif" : "11px sans-serif";
            mercatorCtx.fillStyle = sat.isSelected ? "#ff4444" : "#00aaff";
            mercatorCtx.textAlign = "left";
            mercatorCtx.textBaseline = "middle";
            mercatorCtx.fillText(name, labelX, labelY + 7);
        });

        // After clearing the map...
        //mercatorCtx.clearRect(0, 0, mercatorCanvasElement.width, mercatorCanvasElement.height);

        // Draw the day/night terminator overlay
        drawDayNightTerminatorMercator(
            mercatorCtx, mercatorCanvasElement.width, mercatorCanvasElement.height);
    }


    function latLonToMercator(latDeg, lonDeg) {
        const currentWidth = mercatorCanvasElement ? mercatorCanvasElement.width : mapWidth;
        const currentHeight = mercatorCanvasElement ? mercatorCanvasElement.height : mapHeight;
        const x = (lonDeg + 180) * (currentWidth / 360);
        const latRad = latDeg * Math.PI / 180;
        const mercN = Math.log(Math.tan((Math.PI / 4) + (latRad / 2)));
        const y = (currentHeight / 2) - (currentWidth * mercN / (2 * Math.PI));
        return {x, y};
    }

    // WINDOW RESIZE HANDLER
    function onWindowResize() {
        if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    window.addEventListener('resize', onWindowResize);

    // STARTUP FUNCTION
    async function start() {
        try {
            await loadConfigs();
            init3D();
            initMercatorView();
            await setupTLESatellites('json/tle/TLE.json');
            if (satellites.length === 0) {
                alert("Warning: No satellite data loaded. Check TLE files.");
            }
            setupHTMLControls();
            updateSatelliteList();
            if (simParams.showOrbit && currentSelectedSatellite) updateOrbitTrajectory(currentSelectedSatellite);
            else {
                simParams.showOrbit = false;
                if (showOrbitToggle) showOrbitToggle.checked = false;
            }
            animate();
        } catch (e) {
            console.error("Critical error during initialization:", e);
            document.body.innerHTML = `<div style="color:red; padding:20px; font-family:monospace;"><h1>Initialization Failed</h1><pre>${e.stack || e.message}</pre><p>Check console and config/TLE files.</p></div>`;
        }
    }

    start();
</script>
</body>
</html>
