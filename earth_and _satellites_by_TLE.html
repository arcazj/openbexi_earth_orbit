<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Satellite Simulation - HTML Controls</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <script src="https://unpkg.com/satellite.js@4.0.0/dist/satellite.min.js"></script>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
          }
        }
    </script>
</head>
<body>
<button id="menuToggleBtn">✕</button>
<div id="ob_menu"></div>
<div id="mercatorContainer">
    <div class="mapBackground">
        <canvas id="mercatorCanvas"></canvas>
    </div>
</div>

<script type="module">

    let usingLocalAssets;
    let GITHUB_REPO_RAW_BASE_URL = "https://raw.githubusercontent.com/arcazj/openbexi_earth_orbit/master/";
    let CONFIG_BASE_URL = GITHUB_REPO_RAW_BASE_URL + "config/";
    let TLE_BASE_URL = GITHUB_REPO_RAW_BASE_URL + "json/tle/";
    let SATELLITES_BASE_URL = GITHUB_REPO_RAW_BASE_URL + "json/satellites/"; // Used by satelliteModelLoader.js as well
    window.SATELLITE_MODELS_BASE_URL = SATELLITES_BASE_URL; // Make it available for satelliteModelLoader

    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
    import {loadConfigs, fetchJSON, getFullGitHubUrl} from './js/SatelliteConfigurationLoader.js';
    import {updateSatelliteInfo, satelliteMenuLoader} from './js/SatelliteMenuLoader.js';
    import {showSatellite, buildAllBeams, clearCurrentDetailedSat} from './js/satelliteModelLoader.js';
    import {addECEFAxes, update3DLabelsPosition, updateECEFAxesVisibility} from './js/EarthFrameLoader.js';
    import {createOrbitFrame, updateOrbitFrame, setOrbitFrameVisibility} from './js/orbitFrameLoader.js';
    import {EARTH_RADIUS_KM, KM_TO_SCENE_UNITS, EARTH_SCENE_RADIUS} from './js/SatelliteConstantLoader.js';

    // Load menu
    const versionNumber = "1.0h"; // Updated version
    const versionRepoUrl = "https://github.com/arcazj/openbexi_earth_orbit";
    const versionText = `version ${versionNumber} - hosted at`;
    document.getElementById('ob_menu').innerHTML = satelliteMenuLoader();

    let scene, camera, renderer, earthMesh, controls;
    let earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig,globalScale;
    let mercatorCtx, mapWidth = 400, mapHeight = 200;
    let satellites = [];
    let orbitLine = null;
    let orbitFrame = null
    let currentSelectedSatellite = null; // This will store the TLE data object for the selected satellite
    let textureLoader;
    let mercatorSatIcon = new Image();
    let mercatorSatIconLoaded = false;
    let detailedSatelliteModel = null; // This will store the THREE.Group from satelliteModelLoader

    const simParams = {
        orbitTypeFilter: "MEO",
        companyFilter: "ALL COMPANY",
        selectedSatelliteName: "None", // Stores the name/ID from the dropdown
        showOrbit: false,
        view3D: true,
        viewMercator: false,
        useHighDefTexture: false,
        showECEFAxes: false,
        showOrbitFrame: false
    };

    let orbitTypeFilterSelect, companyFilterSelect, satelliteCountDisplay;
    let view3DToggle, viewMercatorToggle, showOrbitToggle, showOrbitFrameToggle;
    let highDefToggleElement, showECEFAxesToggleElement, showOrbitFrameToggleElement;
    let satelliteSelectDropdown, satelliteInfoDiv;
    let mercatorContainer, mercatorCanvasElement, mapBackgroundDiv;
    let controlsContainerElement, menuToggleBtnElement, versionDisplayElement;
    let labelXecrDiv, labelYecrDiv, labelZecrDiv, labelNorthPoleDiv, labelEquatorLineDiv, labelGreenwichMeridianDiv;

    function isMobileDevice() {
        return /Android|iPhone|iPad|iPod|BlackBerry|Windows Phone/i.test(navigator.userAgent || navigator.vendor || window.opera);
    }

    function updateEarthTexture() {
        if (!earthMesh || !textureLoader || !earthConfig) {
            console.warn("updateEarthTexture: Missing critical components.");
            return;
        }

        const hdTextureFullUrl = getFullGitHubUrl(earthConfig.texture);
        const lightTextureFullUrl = getFullGitHubUrl(earthConfig.textureLight);
        const textureToLoad = simParams.useHighDefTexture ? hdTextureFullUrl : lightTextureFullUrl;

        if (!textureToLoad) {
            console.error("Earth Texture URL is null. Check config paths and getFullGitHubUrl logic.");
            // Apply a very basic material if texture path is null
            earthMesh.material.map = null; // Remove any existing map
            earthMesh.material.color.set(0x1a237e); // A solid blue color
            earthMesh.material.needsUpdate = true;
            return;
        }
        console.log("Attempting to load Earth texture:", textureToLoad);

        textureLoader.load(textureToLoad,
            (texture) => {
                earthMesh.material.map = texture;
                earthMesh.material.color.set(0xffffff); // Reset color if texture loads
                earthMesh.material.needsUpdate = true;
                console.log("Earth texture successfully updated to:", textureToLoad);
            },
            undefined, // onProgress callback (optional)
            (err) => {
                //console.error('Error loading Earth texture from:', textureToLoad, err, '. Using placeholder.');
                // Fallback to a placeholder image from placehold.co
                const placeholderUrl = `https://placehold.co/${simParams.useHighDefTexture ? '4096x2048' : '1024x512'}/1c313a/ffffff?text=Earth+Texture+Load+Error`;
                textureLoader.load(placeholderUrl, (fallbackMap) => {
                    earthMesh.material.map = fallbackMap;
                    earthMesh.material.needsUpdate = true;
                });
            }
        );
    }

    function init3D() {
        /* ───────── Scene, Camera, Renderer ───────── */
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
            sceneConfig.camera.fov,
            window.innerWidth / window.innerHeight,
            sceneConfig.camera.near,
            sceneConfig.camera.far
        );
        camera.position.set(...sceneConfig.camera.position);

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        /* expose for other modules (orbitFrame labels need them) */
        window.renderer = renderer;
        window.camera = camera;

        /* ───────── Lighting ───────── */
        scene.add(new THREE.AmbientLight(
            sceneConfig.ambientLight.color,
            sceneConfig.ambientLight.intensity
        ));

        const dirLight = new THREE.DirectionalLight(
            sceneConfig.directionalLight.color,
            sceneConfig.directionalLight.intensity
        );
        dirLight.position.set(...sceneConfig.directionalLight.position);
        scene.add(dirLight);

        /* ───────── Earth mesh ───────── */
        textureLoader = new THREE.TextureLoader();
        const earthMat = new THREE.MeshPhongMaterial({color: 0xffffff}); // texture applied later
        earthMesh = new THREE.Mesh(
            new THREE.SphereGeometry(EARTH_SCENE_RADIUS, 64, 64),
            earthMat
        );
        scene.add(earthMesh);
        updateEarthTexture();

        /* ───────── ECEF Axes (green) ───────── */
        addECEFAxes(scene);
        updateECEFAxesVisibility(simParams);

        /* ───────── LVLH Orbit‑Frame (hidden until user toggles) ───────── */
        orbitFrame = createOrbitFrame(scene);           // default 10 000 km length
        setOrbitFrameVisibility(orbitFrame, false);     // start invisible

        /* ───────── OrbitControls ───────── */
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = controlsConfig.enableDamping;
        controls.dampingFactor = controlsConfig.dampingFactor;
        controls.minDistance = EARTH_SCENE_RADIUS * 0.4;   // prevent inside‑Earth zoom
        controls.maxDistance = EARTH_SCENE_RADIUS * 20;    // generous zoom‑out
        controls.enableZoom = true;
    }


    function initMercatorView() {
        mercatorContainer = document.getElementById("mercatorContainer");
        mapBackgroundDiv = mercatorContainer.querySelector(".mapBackground");
        mercatorCanvasElement = document.getElementById("mercatorCanvas");

        mapWidth = mapBackgroundDiv.clientWidth;
        mapHeight = mapBackgroundDiv.clientHeight;
        mercatorCanvasElement.width = mapWidth;
        mercatorCanvasElement.height = mapHeight;
        mercatorCtx = mercatorCanvasElement.getContext("2d");

        const remoteMapBgUrl = getFullGitHubUrl('textures/earthmap1k.jpg');

        if (remoteMapBgUrl) {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                mapBackgroundDiv.style.backgroundImage = `url(${remoteMapBgUrl})`;
                mapBackgroundDiv.classList.remove('fallback-css');
                console.log("Mercator map background texture loaded:", remoteMapBgUrl);
            };
            img.onerror = () => {
                console.warn(`Mercator map background '${remoteMapBgUrl}' failed. Applying CSS fallback.`);
                mapBackgroundDiv.classList.add('fallback-css');
            };
            img.src = remoteMapBgUrl;
        } else {
            console.warn("Mercator map background URL is null. Applying CSS fallback.");
            mapBackgroundDiv.classList.add('fallback-css');
        }

        const mercatorIconFullUrl = getFullGitHubUrl(satelliteConfig.mercatorIcon || 'icons/ob_satellite.png');
        if (mercatorIconFullUrl) {
            mercatorSatIcon.crossOrigin = "Anonymous";
            mercatorSatIcon.onload = () => {
                mercatorSatIconLoaded = true;
                console.log("Mercator satellite icon loaded from:", mercatorSatIcon.src);
            };
            mercatorSatIcon.onerror = () => {
                console.error("Mercator satellite icon failed to load from:", mercatorIconFullUrl, ". Using placeholder.");
                mercatorSatIcon.src = 'https://placehold.co/16x16/ffffff/000000?text=S';
                mercatorSatIcon.onload = () => {
                    mercatorSatIconLoaded = true;
                };
            };
            mercatorSatIcon.src = mercatorIconFullUrl;
        } else {
            console.error("Mercator satellite icon path is null. Using placeholder.");
            mercatorSatIcon.src = 'https://placehold.co/16x16/ffffff/000000?text=S';
            mercatorSatIcon.onload = () => {
                mercatorSatIconLoaded = true;
            };
        }
    }

    async function setupTLESatellites() {
        console.log("Attempting to load TLE data from:", TLE_BASE_URL);
        const primaryTleUrl = TLE_BASE_URL + 'TLE.json';

        try {
            let tleData = await fetchJSON(primaryTleUrl);

            if (!Array.isArray(tleData) || tleData.length === 0) {
                console.warn(`TLE data from ${primaryTleUrl} failed or is empty.`);
                // If primary GitHub fails AND we are not already in local mode, try backup GitHub URL
                if (!usingLocalAssets) {
                    const backupTleUrl = GITHUB_REPO_RAW_BASE_URL + "json/tle/" + 'TLE_backup.json'; // Assuming backup is in the same base
                    console.log("Attempting backup TLE from GitHub:", backupTleUrl);
                    tleData = await fetchJSON(backupTleUrl);
                    if (!Array.isArray(tleData) || tleData.length === 0) {
                        console.warn(`Backup TLE data from ${backupTleUrl} also failed or is empty.`);
                    } else {
                        console.log("Loaded TLE data from GitHub backup source.");
                    }
                }
                // If still no data (either local failed, or both GitHub primary/backup failed)
                if (!Array.isArray(tleData) || tleData.length === 0) {
                    const userMessage = "Critical Error: Failed to load satellite TLE data from all available sources. Satellites will not be displayed.";
                    console.error(userMessage);
                    // Display user-facing error
                    const errorDiv = document.createElement('div');
                    errorDiv.style.cssText = "position:fixed; top:10px; left:10px; padding:10px; background:red; color:white; z-index:1000;";
                    errorDiv.innerText = userMessage;
                    document.body.appendChild(errorDiv);
                    // No need for setTimeout, this is a critical error.
                    processSatellites([], null); // Process with empty data
                    return;
                }
            }

            const satIconFullUrl = getFullGitHubUrl(satelliteConfig.icon || 'icons/ob_satellite.png');
            let satMaterial;

            if (!satIconFullUrl) {
                console.error("3D Satellite icon path is null (check satelliteConfig.icon). Using placeholder material.");
                // Create a very simple placeholder material if texture path is null
                const placeholderCanvas = document.createElement('canvas');
                placeholderCanvas.width = 32;
                placeholderCanvas.height = 32;
                const ctx = placeholderCanvas.getContext('2d');
                ctx.fillStyle = 'red';
                ctx.fillRect(0, 0, 32, 32);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('S', 16, 16);
                const placeholderTexture = new THREE.CanvasTexture(placeholderCanvas);
                satMaterial = new THREE.SpriteMaterial({map: placeholderTexture});
            } else {
                satMaterial = new THREE.SpriteMaterial({
                    map: textureLoader.load(satIconFullUrl,
                        () => { /* onLoad */
                            console.log("3D Satellite icon loaded from:", satIconFullUrl);
                        },
                        undefined, // onProgress
                        (err) => { // onError
                            console.error('Error loading 3D satellite icon from:', satIconFullUrl, err, '. Using placeholder.');
                            if (satMaterial) { // Ensure satMaterial exists
                                const errorPlaceholderUrl = 'https://placehold.co/32x32/ff0000/ffffff?text=S_ERR';
                                satMaterial.map = textureLoader.load(errorPlaceholderUrl); // Load placeholder
                                satMaterial.needsUpdate = true;
                            }
                        })
                });
            }
            processSatellites(tleData, satMaterial);

        } catch (err) {
            console.error("Error in setupTLESatellites (fetching/processing TLEs):", err);
            const userMessage = "Error setting up satellite data. Some satellites may not display correctly. Check console for details.";
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = "position:fixed; top:10px; left:10px; padding:10px; background:orange; color:black; z-index:1000;";
            errorDiv.innerText = userMessage;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 7000);
            processSatellites([], null); // Attempt to continue with empty data
        }
    }


    function processSatellites(tleData, baseMaterial) {
        // Clear existing satellites from scene and array
        satellites.forEach(s => {
            if (s.mesh) scene.remove(s.mesh);
            // If s.label and s.label.element, handle removal if CSS2DObjects were used for sprites
        });
        satellites.length = 0; // Empty the array

        if (!tleData || tleData.length === 0) {
            console.warn("No TLE data to process.");
            if (typeof updateSatelliteList === "function") updateSatelliteList(); // Update UI
            return;
        }
        if (!baseMaterial) {
            console.error("Base material for satellites is not available. Cannot create satellite sprites.");
            if (typeof updateSatelliteList === "function") updateSatelliteList(); // Update UI
            return;
        }

        tleData.forEach(item => {
            const {company, satellite_name, norad_id, type, launch_date, tle_line1, tle_line2} = item;
            if (!tle_line1 || !tle_line2) {
                console.warn(`Skipping satellite ${satellite_name || norad_id}: missing TLE line1 or line2.`);
                return;
            }
            try {
                const satrec = satellite.twoline2satrec(tle_line1, tle_line2);
                // Check for common error: epoch year. satellite.js might parse ' yyddd...' as 19yy if yy > 56.
                // Modern TLEs use 'yyddd...'. If satrec.epochyr < 2000 (and yy > 56), it's likely 20yy.
                // This is a heuristic. satellite.js handles most cases, but good to be aware.
                // No direct fix here, assuming satellite.js handles it.

                if (!satrec) { // satellite.js returns false if TLE is fundamentally invalid
                    throw new Error("Failed to parse TLE (twoline2satrec returned false).");
                }


                const sprite = new THREE.Sprite(baseMaterial.clone()); // Clone material for individual control if needed
                sprite.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
                scene.add(sprite);

                satellites.push({
                    mesh: sprite, // The THREE.Sprite object
                    satrec: satrec, // The parsed TLE data from satellite.js
                    orbitType: type || "N/A",
                    company: company || "N/A",
                    satellite_name: satellite_name || `NORAD ${norad_id}`, // Use NORAD ID if name is missing
                    norad_id: norad_id,
                    launch_date: launch_date || "N/A",
                    tle_line1: tle_line1,
                    tle_line2: tle_line2,
                    isSelected: false // Track selection state
                });
            } catch (e) {
                console.error(`Error processing TLE for ${satellite_name || norad_id} (NORAD: ${norad_id}): ${e.message}. TLE1: ${tle_line1}, TLE2: ${tle_line2}`);
                // Optionally, skip adding this satellite or add it with an error state
            }
        });
        console.log(`${satellites.length} satellites processed and added to the scene.`);
        if (typeof updateSatelliteList === "function") updateSatelliteList(); // Update UI elements
    }


    function setupHTMLControls() {
        controlsContainerElement = document.getElementById('controlsContainer');
        menuToggleBtnElement = document.getElementById('menuToggleBtn');
        versionDisplayElement = document.getElementById('versionDisplay');

        if (versionDisplayElement) {
            const versionLink = document.createElement('a');
            versionLink.href = versionRepoUrl;
            versionLink.textContent = `GitHub Repo`;
            versionLink.target = "_blank"; // Open in new tab
            versionDisplayElement.textContent = `${versionText} `;
            versionDisplayElement.appendChild(versionLink);
        }


        orbitTypeFilterSelect = document.getElementById('orbitTypeFilter');
        companyFilterSelect = document.getElementById('companyFilter');
        satelliteCountDisplay = document.getElementById('satelliteCountDisplay');

        view3DToggle = document.getElementById('view3DToggle');
        viewMercatorToggle = document.getElementById('viewMercatorToggle');
        highDefToggleElement = document.getElementById('highDefToggle');
        showECEFAxesToggleElement = document.getElementById('showECEFAxesToggle');
        showOrbitFrameToggleElement = document.getElementById('showOrbitFrameToggle');
        showOrbitToggle = document.getElementById('showOrbitToggle');

        satelliteSelectDropdown = document.getElementById('satelliteSelect');
        satelliteInfoDiv = document.getElementById('satelliteInfo');

        // Axis labels
        labelXecrDiv = document.getElementById('labelXecr');
        labelYecrDiv = document.getElementById('labelYecr');
        labelZecrDiv = document.getElementById('labelZecr');
        labelNorthPoleDiv = document.getElementById('labelNorthPole');
        labelEquatorLineDiv = document.getElementById('labelEquatorLine');
        labelGreenwichMeridianDiv = document.getElementById('labelGreenwichMeridian');


        // Set initial values from simParams
        orbitTypeFilterSelect.value = simParams.orbitTypeFilter;
        view3DToggle.checked = simParams.view3D;
        viewMercatorToggle.checked = simParams.viewMercator;
        if (highDefToggleElement) highDefToggleElement.checked = simParams.useHighDefTexture;
        if (showECEFAxesToggleElement) showECEFAxesToggleElement.checked = simParams.showECEFAxes;
        if (showOrbitFrameToggleElement) showOrbitFrameToggleElement.checked = simParams.showOrbitFrame;
        showOrbitToggle.checked = simParams.showOrbit;

        // Event Listeners
        orbitTypeFilterSelect.addEventListener('change', (e) => {
            simParams.orbitTypeFilter = e.target.value;
            simParams.showOrbit = false; // Reset orbit display on filter change
            if (showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry(); // Clear orbit lines etc.
            updateSatelliteList(); // Refilter and update display
        });

        companyFilterSelect.addEventListener('change', (e) => {
            simParams.companyFilter = e.target.value;
            simParams.showOrbit = false; // Reset orbit display
            if (showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry();
            updateSatelliteList();
        });

        view3DToggle.addEventListener('change', (e) => simParams.view3D = e.target.checked);
        viewMercatorToggle.addEventListener('change', (e) => simParams.viewMercator = e.target.checked);

        if (highDefToggleElement) {
            highDefToggleElement.addEventListener('change', (e) => {
                simParams.useHighDefTexture = e.target.checked;
                updateEarthTexture(); // Reload Earth texture
            });
        }
        if (showECEFAxesToggleElement) {
            showECEFAxesToggleElement.addEventListener('change', (e) => {
                simParams.showECEFAxes = e.target.checked;
                updateECEFAxesVisibility(simParams); // Toggle axes and labels
            });
        }

        if (showOrbitFrameToggleElement) {
            showOrbitFrameToggleElement.addEventListener('change', e => {
                simParams.showOrbitFrame = e.target.checked;
                if (orbitFrame) setOrbitFrameVisibility(orbitFrame, simParams.showOrbitFrame);
            });
        }

        showOrbitToggle.addEventListener('change', (e) => {
            simParams.showOrbit = e.target.checked;
            if (currentSelectedSatellite) { // Check if a satellite object is selected
                updateOrbitTrajectory(currentSelectedSatellite); // Pass the satellite data object
            } else if (simParams.showOrbit) {
                // If showOrbit is checked but no satellite is selected, uncheck it
                simParams.showOrbit = false;
                e.target.checked = false;
                // Optionally, inform the user to select a satellite first
            }
        });

        satelliteSelectDropdown.addEventListener('change', handleSatelliteDropdownChange);


        // Collapsible sections
        document.querySelectorAll('#controlsContainer h3[data-collapsible-target]').forEach(header => {
            const targetId = header.dataset.collapsibleTarget;
            const targetContent = document.getElementById(targetId);
            const icon = header.querySelector('.toggle-icon');

            if (targetContent && icon) {
                // Default to expanded
                targetContent.classList.remove('collapsed');
                icon.classList.remove('collapsed');
                icon.textContent = '▾'; // Down arrow for expanded

                header.addEventListener('click', () => {
                    targetContent.classList.toggle('collapsed');
                    icon.classList.toggle('collapsed');
                    icon.textContent = targetContent.classList.contains('collapsed') ? '▸' : '▾'; // Right for collapsed, Down for expanded
                });
            }
        });

        // Menu toggle button
        if (menuToggleBtnElement && controlsContainerElement) {
            menuToggleBtnElement.addEventListener('click', () => {
                controlsContainerElement.classList.toggle('menu-hidden');
                menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕'; // Hamburger or X
            });
            // Set initial state based on class (e.g., if 'menu-hidden' is default)
            menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕';
        }
    }

    async function handleSatelliteDropdownChange(event) {
        const selectedNameInDropdown = event.target.value; // This is satellite_name or "None"
        simParams.selectedSatelliteName = selectedNameInDropdown;

        // If a detailed model was previously shown, ensure its corresponding TLE sprite is made visible again.
        if (detailedSatelliteModel && detailedSatelliteModel.userData && detailedSatelliteModel.userData.noradId) {
            const prevTleSat = satellites.find(s => s.norad_id.toString() === detailedSatelliteModel.userData.noradId.toString());
            if (prevTleSat && prevTleSat.mesh) {
                prevTleSat.mesh.visible = true; // Make TLE sprite visible
                prevTleSat.isSelected = false;
                // Reset visual cues for the TLE sprite if any were changed
                prevTleSat.mesh.material.color.set(0xffffff);
                prevTleSat.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
            }
        }

        clearDetailedSatelliteView(); // Clears current detailed model from scene
        removeAllGeometry(); // Clears orbit lines

        if (selectedNameInDropdown === "None") {
            currentSelectedSatellite = null; // No TLE data object selected
            updateSatelliteInfo(satelliteInfoDiv, null);
            resetCameraToDefault();
            // Ensure all TLE sprites are reset visually if needed (updateSatelliteList handles this based on currentSelectedSatellite)
            updateSatelliteList(); // This will ensure correct visual state for sprites
            return;
        }

        // Find the satellite data object from the `satellites` array by its name
        const tleSatData = satellites.find(s => s.satellite_name === selectedNameInDropdown && s.mesh && s.mesh.visible);

        if (!tleSatData) {
            console.warn(`Satellite named "${selectedNameInDropdown}" not found or not visible in current filter.`);
            currentSelectedSatellite = null;
            updateSatelliteInfo(satelliteInfoDiv, null);
            // Potentially reset dropdown to "None" if the selected satellite is no longer valid
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
            simParams.selectedSatelliteName = "None";
            return;
        }

        currentSelectedSatellite = tleSatData; // Store the actual satellite data object
        updateSatelliteInfo(satelliteInfoDiv, tleSatData);
        if (simParams.showOrbit) {
            updateOrbitTrajectory(tleSatData);
        }

        // Attempt to load the detailed model
        // The SATELLITES_BASE_URL is already configured (local or remote)
        let fileUrl = (usingLocalAssets ? "json/satellites/" : SATELLITES_BASE_URL) + `${tleSatData.norad_id}.json`;

        let fileExists = await checkFileExists(fileUrl);
        if (!fileExists && !usingLocalAssets) { // If GitHub primary fails, try GitHub backup structure if one existed
            // This example assumes SATELLITES_BASE_URL is the primary. If you have a distinct backup base, use it.
            // For simplicity, we'll assume if primary SATELLITES_BASE_URL fails, we try local next if applicable.
            console.warn(`Primary model file ${fileUrl} not found.`);
        }


        if (!fileExists && usingLocalAssets) { // If primary (which is local if usingLocalAssets) fails
            console.warn(`Local model file ${fileUrl} not found.`);
            // No other place to check if already local
        } else if (!fileExists && !usingLocalAssets) { // If primary GitHub failed, now try local path as a general fallback
            console.warn(`GitHub model file ${fileUrl} not found, attempting local fallback.`);
            fileUrl = "json/satellites/" + `${tleSatData.norad_id}.json`; // Standard local path
            fileExists = await checkFileExists(fileUrl);
        }


        if (fileExists) {
            await loadAndDisplayDetailedSatellite(tleSatData.norad_id, tleSatData);
        } else {
            // If no specific model, try loading a generic/default model (e.g., noradId "0" or "default")
            console.warn(`Satellite data file for NORAD ${tleSatData.norad_id} not found at any checked location. Attempting to load default model.`);
            // Before loading default, ensure the selected TLE sprite is correctly highlighted
            selectSatelliteSprite(tleSatData); // Visually select the TLE sprite
            flyCameraToSatellite(tleSatData.mesh, 1000, true); // Fly to the TLE sprite

            // Optionally, try to load a "default.json" or "0.json" if you have one
            // For now, we just log and don't load a detailed model if specific one not found.
            // await loadAndDisplayDetailedSatellite("0", null); // Pass null for tleData if it's a generic model
        }
    }


    async function checkFileExists(url) {
        try {
            const response = await fetch(url, {method: 'HEAD'});
            return response.ok;
        } catch (error) {
            // Network errors or CORS issues can cause fetch to reject
            console.error('Error checking file existence (HEAD request failed):', url, error);
            return false;
        }
    }

    async function loadAndDisplayDetailedSatellite(noradId, tleSatData) {
        console.log(`Attempting to load detailed model for NORAD ID: ${noradId}`);
        const newModel = await showSatellite(noradId, scene);
        //const newbeams = await buildAllBeamMeshes(noradId, newModel.userData.payload.transponders);
        const newbeams = await buildAllBeams(noradId, currentSelectedSatellite, newModel.userData.payload.transponders);

        if (newModel) {
            detailedSatelliteModel = newModel; // Store the THREE.Group
            detailedSatelliteModel.userData.noradId = noradId; // Ensure NORAD ID is stored on the model

            if (tleSatData && tleSatData.satrec) {
                currentSelectedSatellite = tleSatData; // This is the TLE data object
                tleSatData.isSelected = true; // Mark TLE data as selected
                if (tleSatData.mesh) {
                    tleSatData.mesh.visible = false; // Hide the corresponding TLE sprite
                }

                // --- Set initial position of the detailed model ---
                const now = new Date();
                const jdayNow = satellite.jday(now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
                const gmstNow = satellite.gstime(jdayNow);
                try {
                    const posVel = satellite.propagate(tleSatData.satrec, now);
                    if (posVel && posVel.position) {
                        const ecf = satellite.eciToEcf(posVel.position, gmstNow);
                        detailedSatelliteModel.position.set(ecf.x * KM_TO_SCENE_UNITS, ecf.z * KM_TO_SCENE_UNITS, ecf.y * KM_TO_SCENE_UNITS);
                        console.log(`[Detailed Model] Initial position set for ${noradId}:`, detailedSatelliteModel.position);
                    } else {
                        console.warn(`[Detailed Model] Propagation failed for initial position of ${noradId}. Model at origin.`);
                    }
                } catch (e) {
                    console.error(`[Detailed Model] Error propagating TLE for initial position of ${noradId}:`, e);
                }
                // --- End set initial position ---

            } else {
                console.warn(`[Detailed Model] TLE data or satrec missing for NORAD ${noradId}. Model loaded at origin, cannot track orbit.`);
                currentSelectedSatellite = null; // No TLE data to track
            }
            if (newbeams) {
                scene.add(newbeams);
            }

            // Deselect other TLE sprites
            satellites.forEach(s => {
                if (s !== tleSatData && s.mesh) {
                    s.isSelected = false;
                    s.mesh.material.color.set(0xffffff); // Reset color
                    s.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1])); // Reset scale
                }
            });

            flyCameraToSatellite(tleSatData.mesh, 3000, false); // Fly to the detailed model itself
            if (simParams.showOrbit && currentSelectedSatellite) {
                updateOrbitTrajectory(currentSelectedSatellite);
            }

        } else {
            console.error("Failed to load detailed satellite model for NORAD ID:", noradId, "(showSatellite returned null)");
            // Fallback: ensure the TLE sprite for this satellite is selected and camera flies to it.
            if (tleSatData) {
                selectSatelliteSprite(tleSatData); // Visually select the TLE sprite
                if (tleSatData.mesh) flyCameraToSatellite(tleSatData.mesh, 1000, true); // Fly to the TLE sprite
            } else {
                if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
                simParams.selectedSatelliteName = "None";
                currentSelectedSatellite = null;
                resetCameraToDefault();
            }
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = "position:fixed; top:10px; left:10px; padding:10px; background:orange; color:black; z-index:1000;";
            errorDiv.innerText = `Failed to load 3D model for satellite NORAD ID: ${noradId}. Displaying TLE marker.`;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }
    }

    function clearDetailedSatelliteView() {
        if (detailedSatelliteModel) {
            const oldNoradId = detailedSatelliteModel.userData ? detailedSatelliteModel.userData.noradId : null;
            clearCurrentDetailedSat(scene);
            scene.remove(detailedSatelliteModel);
            detailedSatelliteModel = null;

            // If a TLE sprite was hidden for this detailed model, make it visible again
            if (oldNoradId) {
                const tleSat = satellites.find(s => s.norad_id.toString() === oldNoradId.toString());
                if (tleSat && tleSat.mesh) {
                    tleSat.mesh.visible = true;
                    // Ensure its isSelected state is false if another sat isn't immediately selected
                    // This is typically handled by updateSatelliteList or selection logic
                }
            }
        }
    }


    const clock = new THREE.Clock();
    let cameraMove = null;

    /**
     * Smooth flight from the current camera position to either a sprite or a
     * detailed satellite model.  For models, we frame them at *least* the same
     * distance used for sprites so the view is consistent.
     *
     * @param {THREE.Object3D} targetObject  The sprite or model to frame.
     * @param {number} [millis=1500]         Flight duration in ms.
     * @param {boolean} [isSprite=false]     Pass true when targetObject is a sprite.
     */
    /**
     * Smooth flight from the current camera position to either a sprite or a
     * detailed satellite model.  For models, we frame them at *least* the same
     * distance used for sprites so the view is consistent.
     *
     * @param {THREE.Object3D} targetObject  The sprite or model to frame.
     * @param {number} [millis=1500]         Flight duration in ms.
     * @param {boolean} [isSprite=false]     Pass true when targetObject is a sprite.
     */
    function flyCameraToSatellite(targetObject, millis = 1500, isSprite = false) {
        if (!targetObject || !camera || !controls) {
            console.warn("flyCameraToSatellite: Missing target, camera, or controls.");
            return;
        }

        const earthCenter = new THREE.Vector3(0, 0, 0);
        const targetPos = new THREE.Vector3().setFromMatrixPosition(targetObject.matrixWorld);
        const dirToTarget = new THREE.Vector3().subVectors(targetPos, earthCenter).normalize();

        let distance;

        /* ---------- sprite path ---------- */
        if (isSprite) {
            distance = EARTH_SCENE_RADIUS * 0.5;          // fixed offset
        }

        /* ---------- detailed‑model path ---------- */
        else {
            // Estimate model diameter then back off ~3× that size
            const bbox = new THREE.Box3().setFromObject(targetObject);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            const modelDiameter = Math.max(size.x, size.y, size.z, 0.5 * KM_TO_SCENE_UNITS * 1000);
            distance = modelDiameter * 45;

            // Make sure we never get *closer* than the sprite framing distance
            distance = Math.max(distance, EARTH_SCENE_RADIUS * 0.5);
        }

        // Final camera position = target position + outward offset
        const endCamPos = new THREE.Vector3().addVectors(
            targetPos,
            dirToTarget.clone().multiplyScalar(distance)
        );

        /* ---------- animation set‑up ---------- */
        const startCamPos = camera.position.clone();
        const startTarget = controls.target.clone();
        const endTarget = targetPos.clone();               // always look at the sat

        cameraMove = {
            startTime: clock.getElapsedTime(),
            duration: millis / 1000,
            startCamPos,
            endCamPos,
            startTarget,
            endTarget
        };

        controls.enabled = false; // re‑enabled when the flight completes
    }


    function resetCameraToDefault() {
        if (camera && controls && sceneConfig && sceneConfig.camera && sceneConfig.camera.position) {
            // Stop any ongoing camera flight
            cameraMove = null;

            const startCamPos = camera.position.clone();
            const endCamPos = new THREE.Vector3(...sceneConfig.camera.position);
            const startTarget = controls.target.clone();
            const endTarget = new THREE.Vector3(0, 0, 0); // Look at Earth center

            cameraMove = {
                startTime: clock.getElapsedTime(),
                duration: 1.0, // 1 second to reset
                startCamPos, endCamPos,
                startTarget, endTarget
            };
            controls.enabled = false; // Disable during animation, re-enable in animate loop
        } else {
            console.warn("Cannot reset camera: camera, controls, or sceneConfig not fully initialized.");
        }
    }

    function updateSatelliteList() {
        if (!satellites || !satelliteSelectDropdown || !companyFilterSelect) {
            console.warn("updateSatelliteList: DOM elements not ready or satellites not loaded.");
            if (satelliteCountDisplay) satelliteCountDisplay.textContent = '0';
            if (satelliteSelectDropdown) satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
            if (companyFilterSelect) {
                const currentCompanyVal = companyFilterSelect.value;
                companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
                if (currentCompanyVal !== "ALL COMPANY") { // Try to preserve if it was specific
                    const opt = document.createElement('option');
                    opt.value = currentCompanyVal;
                    opt.textContent = currentCompanyVal;
                    companyFilterSelect.appendChild(opt);
                    companyFilterSelect.value = currentCompanyVal;
                }
            }
            return;
        }

        const filteredTLEs = satellites.filter(s =>
            (simParams.orbitTypeFilter === "ALL" || s.orbitType === simParams.orbitTypeFilter) &&
            (simParams.companyFilter === "ALL COMPANY" || s.company === simParams.companyFilter)
        );

        // Update visibility of TLE sprites
        satellites.forEach(s => {
            if (s.mesh) {
                const isVisibleInFilter = filteredTLEs.includes(s);
                // A TLE sprite is visible if it's in the current filter AND
                // (EITHER no detailed model is shown OR the detailed model shown is NOT this TLE sprite's satellite)
                const isDetailedModelForThisSat = detailedSatelliteModel && detailedSatelliteModel.userData && detailedSatelliteModel.userData.noradId === s.norad_id.toString();
                s.mesh.visible = isVisibleInFilter && !isDetailedModelForThisSat;

                if (s.mesh.visible) { // Apply visual cues only if the sprite is visible
                    const isActuallySelected = currentSelectedSatellite === s; // s is the TLE data object
                    s.mesh.material.color.set(isActuallySelected ? 0xff0000 : 0xffffff); // Red if selected, white otherwise
                    const baseScale = satelliteConfig.scale || [0.1, 0.1, 0.1];
                    s.mesh.scale.set(...(isActuallySelected ? baseScale.map(v => v * 1.5) : baseScale));
                }
            }
        });


        if (satelliteCountDisplay) satelliteCountDisplay.textContent = filteredTLEs.length.toString();

        // Repopulate company filter based on *all* satellites, not just filtered ones, to allow broader selection
        const uniqueCompanies = Array.from(new Set(satellites.map(s => s.company))).sort();
        const currentCompanySelection = companyFilterSelect.value; // Preserve current selection if possible
        companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
        uniqueCompanies.forEach(comp => {
            if (comp && comp !== "N/A") { // Filter out "N/A" or empty company names if desired
                const option = document.createElement('option');
                option.value = comp;
                option.textContent = comp;
                companyFilterSelect.appendChild(option);
            }
        });
        // Try to restore previous selection, or default to "ALL COMPANY"
        if (uniqueCompanies.includes(currentCompanySelection)) {
            companyFilterSelect.value = currentCompanySelection;
        } else {
            companyFilterSelect.value = "ALL COMPANY"; // Default if previous selection is no longer valid
            // simParams.companyFilter = "ALL COMPANY"; // Also update simParams if it changed
        }


        // Repopulate satellite dropdown based on *filtered* TLEs
        const currentDropdownValue = satelliteSelectDropdown.value; // Name of the satellite
        satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
        filteredTLEs.forEach(s => {
            const option = document.createElement('option');
            option.value = s.satellite_name; // Value is the name
            option.textContent = s.satellite_name;
            satelliteSelectDropdown.appendChild(option);
        });

        // Try to restore selection in dropdown
        if (filteredTLEs.some(s => s.satellite_name === currentDropdownValue)) {
            satelliteSelectDropdown.value = currentDropdownValue;
        } else {
            // If the previously selected satellite is no longer in the filtered list
            satelliteSelectDropdown.value = "None";
            simParams.selectedSatelliteName = "None";
            if (currentSelectedSatellite && !filteredTLEs.includes(currentSelectedSatellite)) {
                // If the actual selected object is no longer in filter, deselect it
                clearDetailedSatelliteView(); // Clear detailed model if it was for this sat
                selectSatelliteSprite(null); // Deselect TLE sprite
                currentSelectedSatellite = null;
                updateSatelliteInfo(satelliteInfoDiv, null);
            }
        }
        // If dropdown is "None" but a detailed model is showing, ensure consistency
        if (satelliteSelectDropdown.value === "None" && detailedSatelliteModel) {
            // This case should ideally be handled by the logic that sets dropdown to "None"
            // but as a safeguard:
            clearDetailedSatelliteView();
            currentSelectedSatellite = null;
            updateSatelliteInfo(satelliteInfoDiv, null);
        }
    }

    // Selects the TLE sprite (visual changes)
    function selectSatelliteSprite(tleSatData) {
        // Deselect any previously selected TLE sprite
        satellites.forEach(s => {
            if (s.mesh && s.isSelected) {
                s.isSelected = false;
                if (s.mesh.visible) { // Only change if visible
                    s.mesh.material.color.set(0xffffff);
                    s.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
                }
            }
        });

        currentSelectedSatellite = tleSatData; // Store the TLE data object

        if (tleSatData && tleSatData.mesh) {
            tleSatData.isSelected = true;
            if (tleSatData.mesh.visible) { // Only change if visible
                tleSatData.mesh.material.color.set(0xff0000); // Red
                tleSatData.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]).map(v => v * 1.5)); // Larger
            }
            simParams.selectedSatelliteName = tleSatData.satellite_name;
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = tleSatData.satellite_name;
            updateOrbitTrajectory(tleSatData);
        } else {
            // Deselecting
            simParams.selectedSatelliteName = "None";
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
            removeAllGeometry(); // Clear orbit line
        }
        updateSatelliteInfo(satelliteInfoDiv, tleSatData); // Update text info panel
    }

    function removeAllGeometry() {
        if (orbitLine) {
            scene.remove(orbitLine);
            orbitLine.geometry.dispose();
            orbitLine.material.dispose();
            orbitLine = null;
        }
        // Add removal for other types of geometry if needed
    }
    function updateOrbitTrajectory(satData) {
        if (!simParams.showOrbit || !satData || !satData.satrec) return;

        const meanMotion = satData.satrec.no;
        const basePeriod = (2 * Math.PI) / meanMotion; // fundamental orbital period in minutes

        let orbitType, periodMinutes;
        if (basePeriod > 1400 && basePeriod < 1470) {
            orbitType = 'GEO';
            periodMinutes = basePeriod; // one revolution
        } else if (basePeriod < 225) {
            orbitType = 'LEO';
            periodMinutes = (24 * Math.PI) / meanMotion; // 12 revs
        } else {
            orbitType = 'MEO';
            periodMinutes = (4 * Math.PI) / meanMotion; // 2 revs
        }

        const numPoints = 360;
        const deltaT = periodMinutes / numPoints;
        const now = new Date();
        const orbitPoints = [];

        for (let i = 0; i <= numPoints; i++) {
            const t = new Date(now.getTime() + i * deltaT * 60000);
            const pv = satellite.propagate(satData.satrec, t);
            if (!pv || !pv.position) continue;

            let pos = pv.position;
            if (orbitType !== 'GEO') {
                const gmst = satellite.gstime(t);
                pos = satellite.eciToEcf(pos, gmst);
            }

            const scale = KM_TO_SCENE_UNITS;
            orbitPoints.push(new THREE.Vector3(
                pos.x * scale,
                pos.z * scale,
                pos.y * scale
            ));
        }

        if (typeof orbitLine !== 'undefined' && orbitLine) {
            scene.remove(orbitLine);
            orbitLine.geometry.dispose();
            orbitLine.material.dispose();
        }

        const geometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
        const material = new THREE.LineBasicMaterial({
            color: orbitType === 'GEO' ? 0xff0000 : 0xff0000
        });

        orbitLine = new THREE.Line(geometry, material);
        scene.add(orbitLine);
        return orbitLine;
    }

    window.addEventListener('keydown', e => {
        if (e.key === 'r') {            // press “r” to reset
            controls.reset();             // OrbitControls’ built‑in reset
            camera.position.set(...sceneConfig.camera.position);
            controls.target.set(0, 0, 0);
        }
    });

    function animate() {
        requestAnimationFrame(animate);// time since last frame

        /*──────────────── Camera easing ────────────────*/
        if (cameraMove) {
            const now = clock.getElapsedTime();
            const t = Math.min((now - cameraMove.startTime) / cameraMove.duration, 1);
            const smooth = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;     // ease‑in‑out quad
            camera.position.lerpVectors(cameraMove.startCamPos, cameraMove.endCamPos, smooth);
            controls.target.lerpVectors(cameraMove.startTarget, cameraMove.endTarget, smooth);
            controls.update();

            if (t >= 1) {                          // flight complete
                cameraMove = null;
                controls.enabled = true;
            }
        } else if (controls && controls.enabled) {
            controls.update();
        }

        /*──────────────── Time & GMST ────────────────*/
        const currentTime = new Date();
        const jdayCurrent = satellite.jday(
            currentTime.getUTCFullYear(), currentTime.getUTCMonth() + 1, currentTime.getUTCDate(),
            currentTime.getUTCHours(), currentTime.getUTCMinutes(), currentTime.getUTCSeconds());
        const gmstCurrent = satellite.gstime(jdayCurrent);

        /*──────────────── Update TLE sprites ────────────────*/
        satellites.forEach(sat => {
            if (sat.mesh && sat.mesh.visible && sat.satrec) {
                try {
                    const pv = satellite.propagate(sat.satrec, currentTime);
                    if (!pv || !pv.position) return;
                    const ecf = satellite.eciToEcf(pv.position, gmstCurrent);
                    sat.mesh.position.set(
                        ecf.x * KM_TO_SCENE_UNITS,
                        ecf.z * KM_TO_SCENE_UNITS,
                        ecf.y * KM_TO_SCENE_UNITS
                    );
                } catch (_) {
                    sat.mesh.visible = false;
                }
            }
        });

        /*──────────────── Update detailed model ────────────────*/
        if (detailedSatelliteModel && detailedSatelliteModel.visible &&
            currentSelectedSatellite && currentSelectedSatellite.satrec) {
            try {
                const pv = satellite.propagate(currentSelectedSatellite.satrec, currentTime);
                if (pv && pv.position) {
                    const ecf = satellite.eciToEcf(pv.position, gmstCurrent);
                    detailedSatelliteModel.position.set(
                        ecf.x * KM_TO_SCENE_UNITS,
                        ecf.z * KM_TO_SCENE_UNITS,
                        ecf.y * KM_TO_SCENE_UNITS
                    );
                }
            } catch (_) { /* keep last good pos */
            }
        }

        /*──────────────── LVLH orbit‑frame arrows ────────────────*/
        if (simParams.showOrbitFrame && orbitFrame &&
            currentSelectedSatellite && currentSelectedSatellite.satrec) {
            try {
                setOrbitFrameVisibility(orbitFrame, simParams.showOrbitFrame);
                const pv = satellite.propagate(currentSelectedSatellite.satrec, currentTime);
                if (pv && pv.position && pv.velocity) {
                    const ecfPos = satellite.eciToEcf(pv.position, gmstCurrent);
                    const ecfVel = satellite.eciToEcf(pv.velocity, gmstCurrent);

                    const posVec = new THREE.Vector3(
                        ecfPos.x * KM_TO_SCENE_UNITS,
                        ecfPos.z * KM_TO_SCENE_UNITS,
                        ecfPos.y * KM_TO_SCENE_UNITS);

                    const velVec = new THREE.Vector3(
                        ecfVel.x * KM_TO_SCENE_UNITS,
                        ecfVel.z * KM_TO_SCENE_UNITS,
                        ecfVel.y * KM_TO_SCENE_UNITS);

                    updateOrbitFrame(orbitFrame, posVec, velVec);
                }
            } catch (_) { /* ignore propagation hiccups */
            }
        }

        /*──────────────── 3‑D vs Mercator views ────────────────*/
        const show3D = simParams.view3D;
        const showMercator = simParams.viewMercator;

        // 3‑D render
        if (renderer) renderer.domElement.style.display = show3D ? 'block' : 'none';
        if (show3D) {
            renderer.render(scene, camera);
            update3DLabelsPosition(camera, simParams);
        } else {
            // hide ECEF labels when 3‑D off
            ['labelXecr', 'labelYecr', 'labelZecr',
                'labelNorthPole', 'labelEquatorLine', 'labelGreenwichMeridian']
                .forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                });
        }

        // Mercator redraw
        if (mercatorContainer) {
            if (showMercator) {
                mercatorContainer.style.display = 'block';
                mercatorContainer.classList.toggle('fullscreen', !show3D);
                updateMercatorMap();        // uses current canvas size
            } else {
                mercatorContainer.style.display = 'none';
            }
        }
    }


    function drawDayNightTerminatorMercator(ctx, width, height) {
        const now = new Date();
        const hoursUTC = now.getUTCHours() + now.getUTCMinutes() / 60;
        const subSolarLon = (hoursUTC * 15) - 180;
        const dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
        const N = dayOfYear;
        const declRad = -Math.asin(0.39779 * Math.cos(0.98565 * (N + 10) * Math.PI / 180 + 1.914 * Math.sin(0.98565 * (N - 2) * Math.PI / 180) * Math.PI / 180));
        const subSolarLat = declRad * 180 / Math.PI;

        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.35)";
        ctx.beginPath();

        const points = [];
        let firstPoint = null, lastPoint = null;

        for (let i = 0; i <= width; i++) {
            const lon = (i / width) * 360 - 180;
            let terminatorLat = Math.atan(-Math.cos((lon - subSolarLon) * Math.PI / 180) / Math.tan(subSolarLat * Math.PI / 180)) * 180 / Math.PI;
            terminatorLat = Math.max(-85.05112878, Math.min(85.05112878, terminatorLat));
            const p = latLonToMercator(terminatorLat, lon);
            points.push(p);
            if (i === 0) firstPoint = p;
            if (i === width) lastPoint = p;
        }

        if (!firstPoint) {
            ctx.restore();
            return;
        }

        ctx.moveTo(firstPoint.x, firstPoint.y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }

        if (subSolarLat > 0) {
            ctx.lineTo(lastPoint.x, height);
            ctx.lineTo(firstPoint.x, height);
        } else {
            ctx.lineTo(lastPoint.x, 0);
            ctx.lineTo(firstPoint.x, 0);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    function updateMercatorMap() {
        if (!mercatorCtx || !mercatorCanvasElement || mercatorContainer.style.display === 'none') return;

        mercatorCtx.clearRect(0, 0, mercatorCanvasElement.width, mercatorCanvasElement.height);

        if (typeof drawDayNightTerminatorMercator === 'function') {
            drawDayNightTerminatorMercator(mercatorCtx, mercatorCanvasElement.width, mercatorCanvasElement.height);
        }

        const now = new Date();
        const jdayNow = satellite.jday(now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
        const gmstNow = satellite.gstime(jdayNow);
        let labelPositions = [];

        const satDrawData = satellites
            .filter(sat => sat.mesh && sat.mesh.visible && sat.satrec)
            .map(sat => {
                try {
                    const posVel = satellite.propagate(sat.satrec, now);
                    if (!posVel || !posVel.position) return null;
                    const geo = satellite.eciToGeodetic(posVel.position, gmstNow);
                    const pt = latLonToMercator(satellite.degreesLat(geo.latitude), satellite.degreesLong(geo.longitude));
                    return {sat, pt, name: sat.satellite_name};
                } catch (e) {
                    return null;
                }
            })
            .filter(Boolean)
            .sort((a, b) => a.pt.y - b.pt.y);

        satDrawData.forEach(data => {
            const {sat, pt, name} = data;
            const iconSize = 12;
            const leaderLength = 15;
            const textPadding = {x: 5, y: 3};

            if (mercatorSatIconLoaded && mercatorSatIcon.complete && mercatorSatIcon.naturalHeight !== 0) {
                mercatorCtx.drawImage(mercatorSatIcon, pt.x - iconSize / 2, pt.y - iconSize / 2, iconSize, iconSize);
            } else {
                mercatorCtx.beginPath();
                mercatorCtx.arc(pt.x, pt.y, iconSize / 2, 0, 2 * Math.PI);
                mercatorCtx.fillStyle = sat.isSelected ? "rgba(255,0,0,0.8)" : "rgba(0,255,0,0.8)";
                mercatorCtx.fill();
            }

            mercatorCtx.font = sat.isSelected ? "bold 11px Arial" : "10px Arial";
            const textMetrics = mercatorCtx.measureText(name);
            const labelWidth = textMetrics.width + 2 * textPadding.x;
            const labelHeight = 12 + 2 * textPadding.y;

            const angles = [-Math.PI / 4, -Math.PI / 2, -3 * Math.PI / 4, Math.PI, 3 * Math.PI / 4, Math.PI / 2, Math.PI / 4, 0];
            let bestPos = null;

            for (const angle of angles) {
                const leaderEndX = pt.x + (iconSize / 2 + leaderLength) * Math.cos(angle);
                const leaderEndY = pt.y + (iconSize / 2 + leaderLength) * Math.sin(angle);
                let textX = leaderEndX + ((Math.cos(angle) >= 0 || Math.abs(Math.cos(angle)) < 0.1) ? textPadding.x : -labelWidth + textPadding.x);
                let textY = leaderEndY - labelHeight / 2;
                const currentLabelRect = {
                    x: textX - textPadding.x,
                    y: textY - textPadding.y,
                    width: labelWidth,
                    height: labelHeight
                };

                let isOverlapping = labelPositions.some(lp =>
                    currentLabelRect.x < lp.x + lp.width && currentLabelRect.x + currentLabelRect.width > lp.x &&
                    currentLabelRect.y < lp.y + lp.height && currentLabelRect.y + currentLabelRect.height > lp.y);

                if (!isOverlapping) {
                    bestPos = {leaderEndX, leaderEndY, textX, textY, labelRect: currentLabelRect};
                    break;
                }
            }

            if (bestPos) {
                labelPositions.push(bestPos.labelRect);
                mercatorCtx.beginPath();
                mercatorCtx.moveTo(pt.x, pt.y);
                mercatorCtx.lineTo(bestPos.leaderEndX, bestPos.leaderEndY);
                mercatorCtx.strokeStyle = "rgba(200, 200, 200, 0.7)";
                mercatorCtx.lineWidth = 1;
                mercatorCtx.stroke();
                mercatorCtx.fillStyle = "rgba(0, 0, 0, 0.6)";
                mercatorCtx.fillRect(bestPos.labelRect.x, bestPos.labelRect.y, bestPos.labelRect.width, bestPos.labelRect.height);
                mercatorCtx.fillStyle = sat.isSelected ? "#ff8080" : "#00ddff";
                mercatorCtx.textAlign = "left";
                mercatorCtx.textBaseline = "middle";
                mercatorCtx.fillText(name, bestPos.textX, bestPos.textY + labelHeight / 2 - textPadding.y / 2 + 1);
            } else {
                mercatorCtx.fillStyle = sat.isSelected ? "#ff4444" : "#00aaff";
                mercatorCtx.textAlign = "center";
                mercatorCtx.textBaseline = "bottom";
                mercatorCtx.fillText(name, pt.x, pt.y - iconSize / 2 - 2);
            }
        });
    }

    function latLonToMercator(latDeg, lonDeg) {
        const currentWidth = mercatorCanvasElement ? mercatorCanvasElement.width : mapWidth;
        const currentHeight = mercatorCanvasElement ? mercatorCanvasElement.height : mapHeight;
        const x = (lonDeg + 180) * (currentWidth / 360);
        const clampedLatDeg = Math.max(-85.05112878, Math.min(85.05112878, latDeg));
        const latRad = clampedLatDeg * Math.PI / 180;
        const mercN = Math.log(Math.tan((Math.PI / 4) + (latRad / 2)));
        const y = (currentHeight / 2) - (currentWidth * mercN / (2 * Math.PI));
        return {x, y};
    }


    function onWindowResize() {
        if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        // If Mercator map is full screen or its container resizes with window, update it too
        if (mercatorContainer && mercatorContainer.style.display !== 'none' && mapBackgroundDiv) {
            const currentMapContainerWidth = mapBackgroundDiv.clientWidth;
            const currentMapContainerHeight = mapBackgroundDiv.clientHeight;
            if (mercatorCanvasElement.width !== currentMapContainerWidth || mercatorCanvasElement.height !== currentMapContainerHeight) {
                mercatorCanvasElement.width = currentMapContainerWidth;
                mercatorCanvasElement.height = currentMapContainerHeight;
                mapWidth = currentMapContainerWidth; // Update global dimension vars if used elsewhere
                mapHeight = currentMapContainerHeight;
                // updateMercatorMap(); // Redraw immediately, or let animate loop handle it
            }
        }
    }

    window.addEventListener('resize', onWindowResize);


    async function start() {
        try {
            const config = await loadConfigs(GITHUB_REPO_RAW_BASE_URL);
            ({
                CONFIG_BASE_URL,
                TLE_BASE_URL,
                SATELLITES_BASE_URL,
                earthConfig,
                constantsConfig,
                satelliteConfig,
                sceneConfig,
                controlsConfig,
                globalScale
            } = config);


            window.SATELLITE_MODELS_BASE_URL = SATELLITES_BASE_URL;

            // Now that configs are loaded (including sceneConfig), initialize 3D environment
            init3D();
            initMercatorView(); // Initialize Mercator view (can be done after 3D)
            await setupTLESatellites(); // Load TLE data and create satellite sprites

            setupHTMLControls(); // Setup UI controls and their event listeners
            updateSatelliteList(); // Populate dropdowns and filter based on initial simParams
            updateECEFAxesVisibility(simParams); // Set initial visibility of ECEF axes and labels

            // Initial orbit display based on simParams and if a satellite is pre-selected (though usually not)
            if (simParams.showOrbit && currentSelectedSatellite) {
                updateOrbitTrajectory(currentSelectedSatellite);
            } else {
                simParams.showOrbit = false; // Ensure it's off if no sat selected
                if (showOrbitToggle) showOrbitToggle.checked = false;
            }

            animate(); // Start the main animation loop
        } catch (e) {
            console.error("Critical error during initialization sequence:", e);
            // Display a user-friendly error message on the page
            document.body.innerHTML = `
                <div style="color:red; background:white; border: 2px solid red; padding:20px; font-family:monospace; margin: 20px;">
                    <h1>Application Initialization Failed</h1>
                    <p>A critical error occurred. Please check the browser console (usually F12) for more details.</p>
                    <pre>Error: ${e.message}</pre>
                    <p>Try refreshing the page. If the problem persists, ensure all resources (configs, TLEs, textures) are accessible (e.g., from GitHub or local paths) and that there are no network issues.</p>
                </div>`;
        }
    }

    start(); // Execute the main startup function
</script>
</body>
</html>
